Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ADD
    COMMA
    COMPARETO
    CONSOLE
    ELSE
    ENUM
    EQUALS
    EVENT
    FOREACH
    IN
    ITEM
    LIST
    NEW
    NULL
    POINT
    REMOVE
    REMOVEAT
    SIZEOF
    STRING
    TUPLE
    TYPEOF
    WRITE
    WRITELINE

Grammar

Rule 0     S' -> expression
Rule 1     expression -> term
Rule 2     expression -> datos declaracion
Rule 3     expression -> declaracion
Rule 4     expression -> term opmat expression
Rule 5     expression -> condicional
Rule 6     expression -> expresionlogic
Rule 7     expression -> expresionlogic connectlog expresionlogic
Rule 8     expresionlogic -> term oplog term
Rule 9     expresionlogic -> TRUE
Rule 10    expresionlogic -> FALSE
Rule 11    expression -> VARIABLE assignacion SEMICOLON
Rule 12    expression -> assignacion VARIABLE SEMICOLON
Rule 13    oper -> VARIABLE assignacion
Rule 14    oper -> assignacion VARIABLE
Rule 15    expression -> WHILE condicional LBRACKET expression RBRACKET
Rule 16    expression -> FOR LPAREN datos declaracion expresionlogic SEMICOLON oper RPAREN LBRACKET expression RBRACKET
Rule 17    expression -> IF condicional LBRACKET expression RBRACKET
Rule 18    condicional -> LPAREN expresionlogic RPAREN
Rule 19    declaracion -> VARIABLE ASSIGNMENT expression SEMICOLON
Rule 20    expression -> LPAREN condicional connectlog expression RPAREN
Rule 21    connectlog -> AND
Rule 22    connectlog -> OR
Rule 23    oplog -> EQUAL
Rule 24    oplog -> NOTEQUAL
Rule 25    oplog -> GREATERTHAN
Rule 26    oplog -> GREATERTHANEQUAL
Rule 27    oplog -> LESSERTHAN
Rule 28    oplog -> LESSERTHANEQUAL
Rule 29    opmat -> PLUS
Rule 30    opmat -> MINUS
Rule 31    opmat -> TIMES
Rule 32    opmat -> DIVIDE
Rule 33    opmat -> MOD
Rule 34    assignacion -> INCREMENT
Rule 35    assignacion -> DECREMENT
Rule 36    assignacion -> COMPASSIGPLUS
Rule 37    assignacion -> COMPASSIGMINUS
Rule 38    assignacion -> COMPASSIGTIMES
Rule 39    assignacion -> COMPASSIGDIVIDE
Rule 40    term -> factor
Rule 41    factor -> VARIABLE
Rule 42    term -> NUMBER
Rule 43    term -> TRUE
Rule 44    term -> FALSE
Rule 45    datos -> BOOL
Rule 46    datos -> BYTE
Rule 47    datos -> CHAR
Rule 48    datos -> DECIMAL
Rule 49    datos -> DOUBLE
Rule 50    datos -> FLOAT
Rule 51    datos -> INT
Rule 52    datos -> LONG
Rule 53    datos -> SBYTE
Rule 54    datos -> SHORT
Rule 55    datos -> UINT
Rule 56    datos -> ULONG
Rule 57    datos -> USHORT
Rule 58    factor -> NUMBER PLUS NUMBER
Rule 59    factor -> NUMBER MINUS NUMBER
Rule 60    factor -> NUMBER TIMES NUMBER
Rule 61    factor -> NUMBER DIVIDE NUMBER
Rule 62    factor -> NUMBER MOD NUMBER
Rule 63    expression -> NUMBER EQUAL NUMBER
Rule 64    expression -> NUMBER NOTEQUAL NUMBER
Rule 65    expression -> NUMBER GREATERTHAN NUMBER
Rule 66    expression -> NUMBER GREATERTHANEQUAL NUMBER
Rule 67    expression -> NUMBER LESSERTHAN NUMBER
Rule 68    expression -> NUMBER LESSERTHANEQUAL NUMBER
Rule 69    expression -> TRUE AND TRUE
Rule 70    expression -> TRUE OR TRUE
Rule 71    expression -> TRUE AND FALSE
Rule 72    expression -> TRUE OR FALSE
Rule 73    expression -> FALSE AND FALSE
Rule 74    expression -> FALSE OR FALSE
Rule 75    expression -> TRUE EQUAL TRUE
Rule 76    expression -> TRUE EQUAL FALSE
Rule 77    expression -> FALSE EQUAL FALSE
Rule 78    expression -> FALSE EQUAL TRUE
Rule 79    expression -> TRUE NOTEQUAL TRUE
Rule 80    expression -> TRUE NOTEQUAL FALSE
Rule 81    expression -> FALSE NOTEQUAL FALSE
Rule 82    expression -> FALSE NOTEQUAL TRUE

Terminals, with rules where they appear

ADD                  : 
AND                  : 21 69 71 73
ASSIGNMENT           : 19
BOOL                 : 45
BYTE                 : 46
CHAR                 : 47
COMMA                : 
COMPARETO            : 
COMPASSIGDIVIDE      : 39
COMPASSIGMINUS       : 37
COMPASSIGPLUS        : 36
COMPASSIGTIMES       : 38
CONSOLE              : 
DECIMAL              : 48
DECREMENT            : 35
DIVIDE               : 32 61
DOUBLE               : 49
ELSE                 : 
ENUM                 : 
EQUAL                : 23 63 75 76 77 78
EQUALS               : 
EVENT                : 
FALSE                : 10 44 71 72 73 73 74 74 76 77 77 78 80 81 81 82
FLOAT                : 50
FOR                  : 16
FOREACH              : 
GREATERTHAN          : 25 65
GREATERTHANEQUAL     : 26 66
IF                   : 17
IN                   : 
INCREMENT            : 34
INT                  : 51
ITEM                 : 
LBRACKET             : 15 16 17
LESSERTHAN           : 27 67
LESSERTHANEQUAL      : 28 68
LIST                 : 
LONG                 : 52
LPAREN               : 16 18 20
MINUS                : 30 59
MOD                  : 33 62
NEW                  : 
NOTEQUAL             : 24 64 79 80 81 82
NULL                 : 
NUMBER               : 42 58 58 59 59 60 60 61 61 62 62 63 63 64 64 65 65 66 66 67 67 68 68
OR                   : 22 70 72 74
PLUS                 : 29 58
POINT                : 
RBRACKET             : 15 16 17
REMOVE               : 
REMOVEAT             : 
RPAREN               : 16 18 20
SBYTE                : 53
SEMICOLON            : 11 12 16 19
SHORT                : 54
SIZEOF               : 
STRING               : 
TIMES                : 31 60
TRUE                 : 9 43 69 69 70 70 71 72 75 75 76 78 79 79 80 82
TUPLE                : 
TYPEOF               : 
UINT                 : 55
ULONG                : 56
USHORT               : 57
VARIABLE             : 11 12 13 14 19 41
WHILE                : 15
WRITE                : 
WRITELINE            : 
error                : 

Nonterminals, with rules where they appear

assignacion          : 11 12 13 14
condicional          : 5 15 17 20
connectlog           : 7 20
datos                : 2 16
declaracion          : 2 3 16
expresionlogic       : 6 7 7 16 18
expression           : 4 15 16 17 19 20 0
factor               : 40
oper                 : 16
oplog                : 8
opmat                : 4
term                 : 1 4 8 8

Parsing method: LALR

state 0

    (0) S' -> . expression
    (1) expression -> . term
    (2) expression -> . datos declaracion
    (3) expression -> . declaracion
    (4) expression -> . term opmat expression
    (5) expression -> . condicional
    (6) expression -> . expresionlogic
    (7) expression -> . expresionlogic connectlog expresionlogic
    (11) expression -> . VARIABLE assignacion SEMICOLON
    (12) expression -> . assignacion VARIABLE SEMICOLON
    (15) expression -> . WHILE condicional LBRACKET expression RBRACKET
    (16) expression -> . FOR LPAREN datos declaracion expresionlogic SEMICOLON oper RPAREN LBRACKET expression RBRACKET
    (17) expression -> . IF condicional LBRACKET expression RBRACKET
    (20) expression -> . LPAREN condicional connectlog expression RPAREN
    (63) expression -> . NUMBER EQUAL NUMBER
    (64) expression -> . NUMBER NOTEQUAL NUMBER
    (65) expression -> . NUMBER GREATERTHAN NUMBER
    (66) expression -> . NUMBER GREATERTHANEQUAL NUMBER
    (67) expression -> . NUMBER LESSERTHAN NUMBER
    (68) expression -> . NUMBER LESSERTHANEQUAL NUMBER
    (69) expression -> . TRUE AND TRUE
    (70) expression -> . TRUE OR TRUE
    (71) expression -> . TRUE AND FALSE
    (72) expression -> . TRUE OR FALSE
    (73) expression -> . FALSE AND FALSE
    (74) expression -> . FALSE OR FALSE
    (75) expression -> . TRUE EQUAL TRUE
    (76) expression -> . TRUE EQUAL FALSE
    (77) expression -> . FALSE EQUAL FALSE
    (78) expression -> . FALSE EQUAL TRUE
    (79) expression -> . TRUE NOTEQUAL TRUE
    (80) expression -> . TRUE NOTEQUAL FALSE
    (81) expression -> . FALSE NOTEQUAL FALSE
    (82) expression -> . FALSE NOTEQUAL TRUE
    (40) term -> . factor
    (42) term -> . NUMBER
    (43) term -> . TRUE
    (44) term -> . FALSE
    (45) datos -> . BOOL
    (46) datos -> . BYTE
    (47) datos -> . CHAR
    (48) datos -> . DECIMAL
    (49) datos -> . DOUBLE
    (50) datos -> . FLOAT
    (51) datos -> . INT
    (52) datos -> . LONG
    (53) datos -> . SBYTE
    (54) datos -> . SHORT
    (55) datos -> . UINT
    (56) datos -> . ULONG
    (57) datos -> . USHORT
    (19) declaracion -> . VARIABLE ASSIGNMENT expression SEMICOLON
    (18) condicional -> . LPAREN expresionlogic RPAREN
    (8) expresionlogic -> . term oplog term
    (9) expresionlogic -> . TRUE
    (10) expresionlogic -> . FALSE
    (34) assignacion -> . INCREMENT
    (35) assignacion -> . DECREMENT
    (36) assignacion -> . COMPASSIGPLUS
    (37) assignacion -> . COMPASSIGMINUS
    (38) assignacion -> . COMPASSIGTIMES
    (39) assignacion -> . COMPASSIGDIVIDE
    (41) factor -> . VARIABLE
    (58) factor -> . NUMBER PLUS NUMBER
    (59) factor -> . NUMBER MINUS NUMBER
    (60) factor -> . NUMBER TIMES NUMBER
    (61) factor -> . NUMBER DIVIDE NUMBER
    (62) factor -> . NUMBER MOD NUMBER

    VARIABLE        shift and go to state 7
    WHILE           shift and go to state 9
    FOR             shift and go to state 10
    IF              shift and go to state 12
    LPAREN          shift and go to state 11
    NUMBER          shift and go to state 13
    TRUE            shift and go to state 14
    FALSE           shift and go to state 15
    BOOL            shift and go to state 17
    BYTE            shift and go to state 18
    CHAR            shift and go to state 19
    DECIMAL         shift and go to state 20
    DOUBLE          shift and go to state 21
    FLOAT           shift and go to state 22
    INT             shift and go to state 23
    LONG            shift and go to state 24
    SBYTE           shift and go to state 25
    SHORT           shift and go to state 26
    UINT            shift and go to state 27
    ULONG           shift and go to state 28
    USHORT          shift and go to state 29
    INCREMENT       shift and go to state 30
    DECREMENT       shift and go to state 31
    COMPASSIGPLUS   shift and go to state 32
    COMPASSIGMINUS  shift and go to state 33
    COMPASSIGTIMES  shift and go to state 34
    COMPASSIGDIVIDE shift and go to state 35

    expression                     shift and go to state 1
    term                           shift and go to state 2
    datos                          shift and go to state 3
    declaracion                    shift and go to state 4
    condicional                    shift and go to state 5
    expresionlogic                 shift and go to state 6
    assignacion                    shift and go to state 8
    factor                         shift and go to state 16

state 1

    (0) S' -> expression .



state 2

    (1) expression -> term .
    (4) expression -> term . opmat expression
    (8) expresionlogic -> term . oplog term
    (29) opmat -> . PLUS
    (30) opmat -> . MINUS
    (31) opmat -> . TIMES
    (32) opmat -> . DIVIDE
    (33) opmat -> . MOD
    (23) oplog -> . EQUAL
    (24) oplog -> . NOTEQUAL
    (25) oplog -> . GREATERTHAN
    (26) oplog -> . GREATERTHANEQUAL
    (27) oplog -> . LESSERTHAN
    (28) oplog -> . LESSERTHANEQUAL

    $end            reduce using rule 1 (expression -> term .)
    SEMICOLON       reduce using rule 1 (expression -> term .)
    RBRACKET        reduce using rule 1 (expression -> term .)
    RPAREN          reduce using rule 1 (expression -> term .)
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    TIMES           shift and go to state 40
    DIVIDE          shift and go to state 41
    MOD             shift and go to state 42
    EQUAL           shift and go to state 43
    NOTEQUAL        shift and go to state 44
    GREATERTHAN     shift and go to state 45
    GREATERTHANEQUAL shift and go to state 46
    LESSERTHAN      shift and go to state 47
    LESSERTHANEQUAL shift and go to state 48

    opmat                          shift and go to state 36
    oplog                          shift and go to state 37

state 3

    (2) expression -> datos . declaracion
    (19) declaracion -> . VARIABLE ASSIGNMENT expression SEMICOLON

    VARIABLE        shift and go to state 50

    declaracion                    shift and go to state 49

state 4

    (3) expression -> declaracion .

    $end            reduce using rule 3 (expression -> declaracion .)
    SEMICOLON       reduce using rule 3 (expression -> declaracion .)
    RBRACKET        reduce using rule 3 (expression -> declaracion .)
    RPAREN          reduce using rule 3 (expression -> declaracion .)


state 5

    (5) expression -> condicional .

    $end            reduce using rule 5 (expression -> condicional .)
    SEMICOLON       reduce using rule 5 (expression -> condicional .)
    RBRACKET        reduce using rule 5 (expression -> condicional .)
    RPAREN          reduce using rule 5 (expression -> condicional .)


state 6

    (6) expression -> expresionlogic .
    (7) expression -> expresionlogic . connectlog expresionlogic
    (21) connectlog -> . AND
    (22) connectlog -> . OR

    $end            reduce using rule 6 (expression -> expresionlogic .)
    SEMICOLON       reduce using rule 6 (expression -> expresionlogic .)
    RBRACKET        reduce using rule 6 (expression -> expresionlogic .)
    RPAREN          reduce using rule 6 (expression -> expresionlogic .)
    AND             shift and go to state 52
    OR              shift and go to state 53

    connectlog                     shift and go to state 51

state 7

    (11) expression -> VARIABLE . assignacion SEMICOLON
    (19) declaracion -> VARIABLE . ASSIGNMENT expression SEMICOLON
    (41) factor -> VARIABLE .
    (34) assignacion -> . INCREMENT
    (35) assignacion -> . DECREMENT
    (36) assignacion -> . COMPASSIGPLUS
    (37) assignacion -> . COMPASSIGMINUS
    (38) assignacion -> . COMPASSIGTIMES
    (39) assignacion -> . COMPASSIGDIVIDE

    ASSIGNMENT      shift and go to state 55
    PLUS            reduce using rule 41 (factor -> VARIABLE .)
    MINUS           reduce using rule 41 (factor -> VARIABLE .)
    TIMES           reduce using rule 41 (factor -> VARIABLE .)
    DIVIDE          reduce using rule 41 (factor -> VARIABLE .)
    MOD             reduce using rule 41 (factor -> VARIABLE .)
    EQUAL           reduce using rule 41 (factor -> VARIABLE .)
    NOTEQUAL        reduce using rule 41 (factor -> VARIABLE .)
    GREATERTHAN     reduce using rule 41 (factor -> VARIABLE .)
    GREATERTHANEQUAL reduce using rule 41 (factor -> VARIABLE .)
    LESSERTHAN      reduce using rule 41 (factor -> VARIABLE .)
    LESSERTHANEQUAL reduce using rule 41 (factor -> VARIABLE .)
    $end            reduce using rule 41 (factor -> VARIABLE .)
    SEMICOLON       reduce using rule 41 (factor -> VARIABLE .)
    RBRACKET        reduce using rule 41 (factor -> VARIABLE .)
    RPAREN          reduce using rule 41 (factor -> VARIABLE .)
    INCREMENT       shift and go to state 30
    DECREMENT       shift and go to state 31
    COMPASSIGPLUS   shift and go to state 32
    COMPASSIGMINUS  shift and go to state 33
    COMPASSIGTIMES  shift and go to state 34
    COMPASSIGDIVIDE shift and go to state 35

    assignacion                    shift and go to state 54

state 8

    (12) expression -> assignacion . VARIABLE SEMICOLON

    VARIABLE        shift and go to state 56


state 9

    (15) expression -> WHILE . condicional LBRACKET expression RBRACKET
    (18) condicional -> . LPAREN expresionlogic RPAREN

    LPAREN          shift and go to state 58

    condicional                    shift and go to state 57

state 10

    (16) expression -> FOR . LPAREN datos declaracion expresionlogic SEMICOLON oper RPAREN LBRACKET expression RBRACKET

    LPAREN          shift and go to state 59


state 11

    (20) expression -> LPAREN . condicional connectlog expression RPAREN
    (18) condicional -> LPAREN . expresionlogic RPAREN
    (18) condicional -> . LPAREN expresionlogic RPAREN
    (8) expresionlogic -> . term oplog term
    (9) expresionlogic -> . TRUE
    (10) expresionlogic -> . FALSE
    (40) term -> . factor
    (42) term -> . NUMBER
    (43) term -> . TRUE
    (44) term -> . FALSE
    (41) factor -> . VARIABLE
    (58) factor -> . NUMBER PLUS NUMBER
    (59) factor -> . NUMBER MINUS NUMBER
    (60) factor -> . NUMBER TIMES NUMBER
    (61) factor -> . NUMBER DIVIDE NUMBER
    (62) factor -> . NUMBER MOD NUMBER

    LPAREN          shift and go to state 58
    TRUE            shift and go to state 63
    FALSE           shift and go to state 64
    NUMBER          shift and go to state 65
    VARIABLE        shift and go to state 66

    condicional                    shift and go to state 60
    expresionlogic                 shift and go to state 61
    term                           shift and go to state 62
    factor                         shift and go to state 16

state 12

    (17) expression -> IF . condicional LBRACKET expression RBRACKET
    (18) condicional -> . LPAREN expresionlogic RPAREN

    LPAREN          shift and go to state 58

    condicional                    shift and go to state 67

state 13

    (63) expression -> NUMBER . EQUAL NUMBER
    (64) expression -> NUMBER . NOTEQUAL NUMBER
    (65) expression -> NUMBER . GREATERTHAN NUMBER
    (66) expression -> NUMBER . GREATERTHANEQUAL NUMBER
    (67) expression -> NUMBER . LESSERTHAN NUMBER
    (68) expression -> NUMBER . LESSERTHANEQUAL NUMBER
    (42) term -> NUMBER .
    (58) factor -> NUMBER . PLUS NUMBER
    (59) factor -> NUMBER . MINUS NUMBER
    (60) factor -> NUMBER . TIMES NUMBER
    (61) factor -> NUMBER . DIVIDE NUMBER
    (62) factor -> NUMBER . MOD NUMBER

  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for GREATERTHAN resolved as shift
  ! shift/reduce conflict for GREATERTHANEQUAL resolved as shift
  ! shift/reduce conflict for LESSERTHAN resolved as shift
  ! shift/reduce conflict for LESSERTHANEQUAL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
    EQUAL           shift and go to state 68
    NOTEQUAL        shift and go to state 69
    GREATERTHAN     shift and go to state 70
    GREATERTHANEQUAL shift and go to state 71
    LESSERTHAN      shift and go to state 72
    LESSERTHANEQUAL shift and go to state 73
    $end            reduce using rule 42 (term -> NUMBER .)
    SEMICOLON       reduce using rule 42 (term -> NUMBER .)
    RBRACKET        reduce using rule 42 (term -> NUMBER .)
    RPAREN          reduce using rule 42 (term -> NUMBER .)
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75
    TIMES           shift and go to state 76
    DIVIDE          shift and go to state 77
    MOD             shift and go to state 78

  ! PLUS            [ reduce using rule 42 (term -> NUMBER .) ]
  ! MINUS           [ reduce using rule 42 (term -> NUMBER .) ]
  ! TIMES           [ reduce using rule 42 (term -> NUMBER .) ]
  ! DIVIDE          [ reduce using rule 42 (term -> NUMBER .) ]
  ! MOD             [ reduce using rule 42 (term -> NUMBER .) ]
  ! EQUAL           [ reduce using rule 42 (term -> NUMBER .) ]
  ! NOTEQUAL        [ reduce using rule 42 (term -> NUMBER .) ]
  ! GREATERTHAN     [ reduce using rule 42 (term -> NUMBER .) ]
  ! GREATERTHANEQUAL [ reduce using rule 42 (term -> NUMBER .) ]
  ! LESSERTHAN      [ reduce using rule 42 (term -> NUMBER .) ]
  ! LESSERTHANEQUAL [ reduce using rule 42 (term -> NUMBER .) ]


state 14

    (69) expression -> TRUE . AND TRUE
    (70) expression -> TRUE . OR TRUE
    (71) expression -> TRUE . AND FALSE
    (72) expression -> TRUE . OR FALSE
    (75) expression -> TRUE . EQUAL TRUE
    (76) expression -> TRUE . EQUAL FALSE
    (79) expression -> TRUE . NOTEQUAL TRUE
    (80) expression -> TRUE . NOTEQUAL FALSE
    (43) term -> TRUE .
    (9) expresionlogic -> TRUE .

  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! reduce/reduce conflict for $end resolved using rule 9 (expresionlogic -> TRUE .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 9 (expresionlogic -> TRUE .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 9 (expresionlogic -> TRUE .)
  ! reduce/reduce conflict for RPAREN resolved using rule 9 (expresionlogic -> TRUE .)
    AND             shift and go to state 79
    OR              shift and go to state 80
    EQUAL           shift and go to state 81
    NOTEQUAL        shift and go to state 82
    PLUS            reduce using rule 43 (term -> TRUE .)
    MINUS           reduce using rule 43 (term -> TRUE .)
    TIMES           reduce using rule 43 (term -> TRUE .)
    DIVIDE          reduce using rule 43 (term -> TRUE .)
    MOD             reduce using rule 43 (term -> TRUE .)
    GREATERTHAN     reduce using rule 43 (term -> TRUE .)
    GREATERTHANEQUAL reduce using rule 43 (term -> TRUE .)
    LESSERTHAN      reduce using rule 43 (term -> TRUE .)
    LESSERTHANEQUAL reduce using rule 43 (term -> TRUE .)
    $end            reduce using rule 9 (expresionlogic -> TRUE .)
    SEMICOLON       reduce using rule 9 (expresionlogic -> TRUE .)
    RBRACKET        reduce using rule 9 (expresionlogic -> TRUE .)
    RPAREN          reduce using rule 9 (expresionlogic -> TRUE .)

  ! EQUAL           [ reduce using rule 43 (term -> TRUE .) ]
  ! NOTEQUAL        [ reduce using rule 43 (term -> TRUE .) ]
  ! $end            [ reduce using rule 43 (term -> TRUE .) ]
  ! SEMICOLON       [ reduce using rule 43 (term -> TRUE .) ]
  ! RBRACKET        [ reduce using rule 43 (term -> TRUE .) ]
  ! RPAREN          [ reduce using rule 43 (term -> TRUE .) ]
  ! AND             [ reduce using rule 9 (expresionlogic -> TRUE .) ]
  ! OR              [ reduce using rule 9 (expresionlogic -> TRUE .) ]


state 15

    (73) expression -> FALSE . AND FALSE
    (74) expression -> FALSE . OR FALSE
    (77) expression -> FALSE . EQUAL FALSE
    (78) expression -> FALSE . EQUAL TRUE
    (81) expression -> FALSE . NOTEQUAL FALSE
    (82) expression -> FALSE . NOTEQUAL TRUE
    (44) term -> FALSE .
    (10) expresionlogic -> FALSE .

  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! reduce/reduce conflict for $end resolved using rule 10 (expresionlogic -> FALSE .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 10 (expresionlogic -> FALSE .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 10 (expresionlogic -> FALSE .)
  ! reduce/reduce conflict for RPAREN resolved using rule 10 (expresionlogic -> FALSE .)
    AND             shift and go to state 83
    OR              shift and go to state 84
    EQUAL           shift and go to state 85
    NOTEQUAL        shift and go to state 86
    PLUS            reduce using rule 44 (term -> FALSE .)
    MINUS           reduce using rule 44 (term -> FALSE .)
    TIMES           reduce using rule 44 (term -> FALSE .)
    DIVIDE          reduce using rule 44 (term -> FALSE .)
    MOD             reduce using rule 44 (term -> FALSE .)
    GREATERTHAN     reduce using rule 44 (term -> FALSE .)
    GREATERTHANEQUAL reduce using rule 44 (term -> FALSE .)
    LESSERTHAN      reduce using rule 44 (term -> FALSE .)
    LESSERTHANEQUAL reduce using rule 44 (term -> FALSE .)
    $end            reduce using rule 10 (expresionlogic -> FALSE .)
    SEMICOLON       reduce using rule 10 (expresionlogic -> FALSE .)
    RBRACKET        reduce using rule 10 (expresionlogic -> FALSE .)
    RPAREN          reduce using rule 10 (expresionlogic -> FALSE .)

  ! EQUAL           [ reduce using rule 44 (term -> FALSE .) ]
  ! NOTEQUAL        [ reduce using rule 44 (term -> FALSE .) ]
  ! $end            [ reduce using rule 44 (term -> FALSE .) ]
  ! SEMICOLON       [ reduce using rule 44 (term -> FALSE .) ]
  ! RBRACKET        [ reduce using rule 44 (term -> FALSE .) ]
  ! RPAREN          [ reduce using rule 44 (term -> FALSE .) ]
  ! AND             [ reduce using rule 10 (expresionlogic -> FALSE .) ]
  ! OR              [ reduce using rule 10 (expresionlogic -> FALSE .) ]


state 16

    (40) term -> factor .

    PLUS            reduce using rule 40 (term -> factor .)
    MINUS           reduce using rule 40 (term -> factor .)
    TIMES           reduce using rule 40 (term -> factor .)
    DIVIDE          reduce using rule 40 (term -> factor .)
    MOD             reduce using rule 40 (term -> factor .)
    EQUAL           reduce using rule 40 (term -> factor .)
    NOTEQUAL        reduce using rule 40 (term -> factor .)
    GREATERTHAN     reduce using rule 40 (term -> factor .)
    GREATERTHANEQUAL reduce using rule 40 (term -> factor .)
    LESSERTHAN      reduce using rule 40 (term -> factor .)
    LESSERTHANEQUAL reduce using rule 40 (term -> factor .)
    $end            reduce using rule 40 (term -> factor .)
    SEMICOLON       reduce using rule 40 (term -> factor .)
    RBRACKET        reduce using rule 40 (term -> factor .)
    RPAREN          reduce using rule 40 (term -> factor .)
    AND             reduce using rule 40 (term -> factor .)
    OR              reduce using rule 40 (term -> factor .)


state 17

    (45) datos -> BOOL .

    VARIABLE        reduce using rule 45 (datos -> BOOL .)


state 18

    (46) datos -> BYTE .

    VARIABLE        reduce using rule 46 (datos -> BYTE .)


state 19

    (47) datos -> CHAR .

    VARIABLE        reduce using rule 47 (datos -> CHAR .)


state 20

    (48) datos -> DECIMAL .

    VARIABLE        reduce using rule 48 (datos -> DECIMAL .)


state 21

    (49) datos -> DOUBLE .

    VARIABLE        reduce using rule 49 (datos -> DOUBLE .)


state 22

    (50) datos -> FLOAT .

    VARIABLE        reduce using rule 50 (datos -> FLOAT .)


state 23

    (51) datos -> INT .

    VARIABLE        reduce using rule 51 (datos -> INT .)


state 24

    (52) datos -> LONG .

    VARIABLE        reduce using rule 52 (datos -> LONG .)


state 25

    (53) datos -> SBYTE .

    VARIABLE        reduce using rule 53 (datos -> SBYTE .)


state 26

    (54) datos -> SHORT .

    VARIABLE        reduce using rule 54 (datos -> SHORT .)


state 27

    (55) datos -> UINT .

    VARIABLE        reduce using rule 55 (datos -> UINT .)


state 28

    (56) datos -> ULONG .

    VARIABLE        reduce using rule 56 (datos -> ULONG .)


state 29

    (57) datos -> USHORT .

    VARIABLE        reduce using rule 57 (datos -> USHORT .)


state 30

    (34) assignacion -> INCREMENT .

    VARIABLE        reduce using rule 34 (assignacion -> INCREMENT .)
    SEMICOLON       reduce using rule 34 (assignacion -> INCREMENT .)
    RPAREN          reduce using rule 34 (assignacion -> INCREMENT .)


state 31

    (35) assignacion -> DECREMENT .

    VARIABLE        reduce using rule 35 (assignacion -> DECREMENT .)
    SEMICOLON       reduce using rule 35 (assignacion -> DECREMENT .)
    RPAREN          reduce using rule 35 (assignacion -> DECREMENT .)


state 32

    (36) assignacion -> COMPASSIGPLUS .

    VARIABLE        reduce using rule 36 (assignacion -> COMPASSIGPLUS .)
    SEMICOLON       reduce using rule 36 (assignacion -> COMPASSIGPLUS .)
    RPAREN          reduce using rule 36 (assignacion -> COMPASSIGPLUS .)


state 33

    (37) assignacion -> COMPASSIGMINUS .

    VARIABLE        reduce using rule 37 (assignacion -> COMPASSIGMINUS .)
    SEMICOLON       reduce using rule 37 (assignacion -> COMPASSIGMINUS .)
    RPAREN          reduce using rule 37 (assignacion -> COMPASSIGMINUS .)


state 34

    (38) assignacion -> COMPASSIGTIMES .

    VARIABLE        reduce using rule 38 (assignacion -> COMPASSIGTIMES .)
    SEMICOLON       reduce using rule 38 (assignacion -> COMPASSIGTIMES .)
    RPAREN          reduce using rule 38 (assignacion -> COMPASSIGTIMES .)


state 35

    (39) assignacion -> COMPASSIGDIVIDE .

    VARIABLE        reduce using rule 39 (assignacion -> COMPASSIGDIVIDE .)
    SEMICOLON       reduce using rule 39 (assignacion -> COMPASSIGDIVIDE .)
    RPAREN          reduce using rule 39 (assignacion -> COMPASSIGDIVIDE .)


state 36

    (4) expression -> term opmat . expression
    (1) expression -> . term
    (2) expression -> . datos declaracion
    (3) expression -> . declaracion
    (4) expression -> . term opmat expression
    (5) expression -> . condicional
    (6) expression -> . expresionlogic
    (7) expression -> . expresionlogic connectlog expresionlogic
    (11) expression -> . VARIABLE assignacion SEMICOLON
    (12) expression -> . assignacion VARIABLE SEMICOLON
    (15) expression -> . WHILE condicional LBRACKET expression RBRACKET
    (16) expression -> . FOR LPAREN datos declaracion expresionlogic SEMICOLON oper RPAREN LBRACKET expression RBRACKET
    (17) expression -> . IF condicional LBRACKET expression RBRACKET
    (20) expression -> . LPAREN condicional connectlog expression RPAREN
    (63) expression -> . NUMBER EQUAL NUMBER
    (64) expression -> . NUMBER NOTEQUAL NUMBER
    (65) expression -> . NUMBER GREATERTHAN NUMBER
    (66) expression -> . NUMBER GREATERTHANEQUAL NUMBER
    (67) expression -> . NUMBER LESSERTHAN NUMBER
    (68) expression -> . NUMBER LESSERTHANEQUAL NUMBER
    (69) expression -> . TRUE AND TRUE
    (70) expression -> . TRUE OR TRUE
    (71) expression -> . TRUE AND FALSE
    (72) expression -> . TRUE OR FALSE
    (73) expression -> . FALSE AND FALSE
    (74) expression -> . FALSE OR FALSE
    (75) expression -> . TRUE EQUAL TRUE
    (76) expression -> . TRUE EQUAL FALSE
    (77) expression -> . FALSE EQUAL FALSE
    (78) expression -> . FALSE EQUAL TRUE
    (79) expression -> . TRUE NOTEQUAL TRUE
    (80) expression -> . TRUE NOTEQUAL FALSE
    (81) expression -> . FALSE NOTEQUAL FALSE
    (82) expression -> . FALSE NOTEQUAL TRUE
    (40) term -> . factor
    (42) term -> . NUMBER
    (43) term -> . TRUE
    (44) term -> . FALSE
    (45) datos -> . BOOL
    (46) datos -> . BYTE
    (47) datos -> . CHAR
    (48) datos -> . DECIMAL
    (49) datos -> . DOUBLE
    (50) datos -> . FLOAT
    (51) datos -> . INT
    (52) datos -> . LONG
    (53) datos -> . SBYTE
    (54) datos -> . SHORT
    (55) datos -> . UINT
    (56) datos -> . ULONG
    (57) datos -> . USHORT
    (19) declaracion -> . VARIABLE ASSIGNMENT expression SEMICOLON
    (18) condicional -> . LPAREN expresionlogic RPAREN
    (8) expresionlogic -> . term oplog term
    (9) expresionlogic -> . TRUE
    (10) expresionlogic -> . FALSE
    (34) assignacion -> . INCREMENT
    (35) assignacion -> . DECREMENT
    (36) assignacion -> . COMPASSIGPLUS
    (37) assignacion -> . COMPASSIGMINUS
    (38) assignacion -> . COMPASSIGTIMES
    (39) assignacion -> . COMPASSIGDIVIDE
    (41) factor -> . VARIABLE
    (58) factor -> . NUMBER PLUS NUMBER
    (59) factor -> . NUMBER MINUS NUMBER
    (60) factor -> . NUMBER TIMES NUMBER
    (61) factor -> . NUMBER DIVIDE NUMBER
    (62) factor -> . NUMBER MOD NUMBER

    VARIABLE        shift and go to state 7
    WHILE           shift and go to state 9
    FOR             shift and go to state 10
    IF              shift and go to state 12
    LPAREN          shift and go to state 11
    NUMBER          shift and go to state 13
    TRUE            shift and go to state 14
    FALSE           shift and go to state 15
    BOOL            shift and go to state 17
    BYTE            shift and go to state 18
    CHAR            shift and go to state 19
    DECIMAL         shift and go to state 20
    DOUBLE          shift and go to state 21
    FLOAT           shift and go to state 22
    INT             shift and go to state 23
    LONG            shift and go to state 24
    SBYTE           shift and go to state 25
    SHORT           shift and go to state 26
    UINT            shift and go to state 27
    ULONG           shift and go to state 28
    USHORT          shift and go to state 29
    INCREMENT       shift and go to state 30
    DECREMENT       shift and go to state 31
    COMPASSIGPLUS   shift and go to state 32
    COMPASSIGMINUS  shift and go to state 33
    COMPASSIGTIMES  shift and go to state 34
    COMPASSIGDIVIDE shift and go to state 35

    term                           shift and go to state 2
    expression                     shift and go to state 87
    datos                          shift and go to state 3
    declaracion                    shift and go to state 4
    condicional                    shift and go to state 5
    expresionlogic                 shift and go to state 6
    assignacion                    shift and go to state 8
    factor                         shift and go to state 16

state 37

    (8) expresionlogic -> term oplog . term
    (40) term -> . factor
    (42) term -> . NUMBER
    (43) term -> . TRUE
    (44) term -> . FALSE
    (41) factor -> . VARIABLE
    (58) factor -> . NUMBER PLUS NUMBER
    (59) factor -> . NUMBER MINUS NUMBER
    (60) factor -> . NUMBER TIMES NUMBER
    (61) factor -> . NUMBER DIVIDE NUMBER
    (62) factor -> . NUMBER MOD NUMBER

    NUMBER          shift and go to state 65
    TRUE            shift and go to state 89
    FALSE           shift and go to state 90
    VARIABLE        shift and go to state 66

    term                           shift and go to state 88
    factor                         shift and go to state 16

state 38

    (29) opmat -> PLUS .

    VARIABLE        reduce using rule 29 (opmat -> PLUS .)
    WHILE           reduce using rule 29 (opmat -> PLUS .)
    FOR             reduce using rule 29 (opmat -> PLUS .)
    IF              reduce using rule 29 (opmat -> PLUS .)
    LPAREN          reduce using rule 29 (opmat -> PLUS .)
    NUMBER          reduce using rule 29 (opmat -> PLUS .)
    TRUE            reduce using rule 29 (opmat -> PLUS .)
    FALSE           reduce using rule 29 (opmat -> PLUS .)
    BOOL            reduce using rule 29 (opmat -> PLUS .)
    BYTE            reduce using rule 29 (opmat -> PLUS .)
    CHAR            reduce using rule 29 (opmat -> PLUS .)
    DECIMAL         reduce using rule 29 (opmat -> PLUS .)
    DOUBLE          reduce using rule 29 (opmat -> PLUS .)
    FLOAT           reduce using rule 29 (opmat -> PLUS .)
    INT             reduce using rule 29 (opmat -> PLUS .)
    LONG            reduce using rule 29 (opmat -> PLUS .)
    SBYTE           reduce using rule 29 (opmat -> PLUS .)
    SHORT           reduce using rule 29 (opmat -> PLUS .)
    UINT            reduce using rule 29 (opmat -> PLUS .)
    ULONG           reduce using rule 29 (opmat -> PLUS .)
    USHORT          reduce using rule 29 (opmat -> PLUS .)
    INCREMENT       reduce using rule 29 (opmat -> PLUS .)
    DECREMENT       reduce using rule 29 (opmat -> PLUS .)
    COMPASSIGPLUS   reduce using rule 29 (opmat -> PLUS .)
    COMPASSIGMINUS  reduce using rule 29 (opmat -> PLUS .)
    COMPASSIGTIMES  reduce using rule 29 (opmat -> PLUS .)
    COMPASSIGDIVIDE reduce using rule 29 (opmat -> PLUS .)


state 39

    (30) opmat -> MINUS .

    VARIABLE        reduce using rule 30 (opmat -> MINUS .)
    WHILE           reduce using rule 30 (opmat -> MINUS .)
    FOR             reduce using rule 30 (opmat -> MINUS .)
    IF              reduce using rule 30 (opmat -> MINUS .)
    LPAREN          reduce using rule 30 (opmat -> MINUS .)
    NUMBER          reduce using rule 30 (opmat -> MINUS .)
    TRUE            reduce using rule 30 (opmat -> MINUS .)
    FALSE           reduce using rule 30 (opmat -> MINUS .)
    BOOL            reduce using rule 30 (opmat -> MINUS .)
    BYTE            reduce using rule 30 (opmat -> MINUS .)
    CHAR            reduce using rule 30 (opmat -> MINUS .)
    DECIMAL         reduce using rule 30 (opmat -> MINUS .)
    DOUBLE          reduce using rule 30 (opmat -> MINUS .)
    FLOAT           reduce using rule 30 (opmat -> MINUS .)
    INT             reduce using rule 30 (opmat -> MINUS .)
    LONG            reduce using rule 30 (opmat -> MINUS .)
    SBYTE           reduce using rule 30 (opmat -> MINUS .)
    SHORT           reduce using rule 30 (opmat -> MINUS .)
    UINT            reduce using rule 30 (opmat -> MINUS .)
    ULONG           reduce using rule 30 (opmat -> MINUS .)
    USHORT          reduce using rule 30 (opmat -> MINUS .)
    INCREMENT       reduce using rule 30 (opmat -> MINUS .)
    DECREMENT       reduce using rule 30 (opmat -> MINUS .)
    COMPASSIGPLUS   reduce using rule 30 (opmat -> MINUS .)
    COMPASSIGMINUS  reduce using rule 30 (opmat -> MINUS .)
    COMPASSIGTIMES  reduce using rule 30 (opmat -> MINUS .)
    COMPASSIGDIVIDE reduce using rule 30 (opmat -> MINUS .)


state 40

    (31) opmat -> TIMES .

    VARIABLE        reduce using rule 31 (opmat -> TIMES .)
    WHILE           reduce using rule 31 (opmat -> TIMES .)
    FOR             reduce using rule 31 (opmat -> TIMES .)
    IF              reduce using rule 31 (opmat -> TIMES .)
    LPAREN          reduce using rule 31 (opmat -> TIMES .)
    NUMBER          reduce using rule 31 (opmat -> TIMES .)
    TRUE            reduce using rule 31 (opmat -> TIMES .)
    FALSE           reduce using rule 31 (opmat -> TIMES .)
    BOOL            reduce using rule 31 (opmat -> TIMES .)
    BYTE            reduce using rule 31 (opmat -> TIMES .)
    CHAR            reduce using rule 31 (opmat -> TIMES .)
    DECIMAL         reduce using rule 31 (opmat -> TIMES .)
    DOUBLE          reduce using rule 31 (opmat -> TIMES .)
    FLOAT           reduce using rule 31 (opmat -> TIMES .)
    INT             reduce using rule 31 (opmat -> TIMES .)
    LONG            reduce using rule 31 (opmat -> TIMES .)
    SBYTE           reduce using rule 31 (opmat -> TIMES .)
    SHORT           reduce using rule 31 (opmat -> TIMES .)
    UINT            reduce using rule 31 (opmat -> TIMES .)
    ULONG           reduce using rule 31 (opmat -> TIMES .)
    USHORT          reduce using rule 31 (opmat -> TIMES .)
    INCREMENT       reduce using rule 31 (opmat -> TIMES .)
    DECREMENT       reduce using rule 31 (opmat -> TIMES .)
    COMPASSIGPLUS   reduce using rule 31 (opmat -> TIMES .)
    COMPASSIGMINUS  reduce using rule 31 (opmat -> TIMES .)
    COMPASSIGTIMES  reduce using rule 31 (opmat -> TIMES .)
    COMPASSIGDIVIDE reduce using rule 31 (opmat -> TIMES .)


state 41

    (32) opmat -> DIVIDE .

    VARIABLE        reduce using rule 32 (opmat -> DIVIDE .)
    WHILE           reduce using rule 32 (opmat -> DIVIDE .)
    FOR             reduce using rule 32 (opmat -> DIVIDE .)
    IF              reduce using rule 32 (opmat -> DIVIDE .)
    LPAREN          reduce using rule 32 (opmat -> DIVIDE .)
    NUMBER          reduce using rule 32 (opmat -> DIVIDE .)
    TRUE            reduce using rule 32 (opmat -> DIVIDE .)
    FALSE           reduce using rule 32 (opmat -> DIVIDE .)
    BOOL            reduce using rule 32 (opmat -> DIVIDE .)
    BYTE            reduce using rule 32 (opmat -> DIVIDE .)
    CHAR            reduce using rule 32 (opmat -> DIVIDE .)
    DECIMAL         reduce using rule 32 (opmat -> DIVIDE .)
    DOUBLE          reduce using rule 32 (opmat -> DIVIDE .)
    FLOAT           reduce using rule 32 (opmat -> DIVIDE .)
    INT             reduce using rule 32 (opmat -> DIVIDE .)
    LONG            reduce using rule 32 (opmat -> DIVIDE .)
    SBYTE           reduce using rule 32 (opmat -> DIVIDE .)
    SHORT           reduce using rule 32 (opmat -> DIVIDE .)
    UINT            reduce using rule 32 (opmat -> DIVIDE .)
    ULONG           reduce using rule 32 (opmat -> DIVIDE .)
    USHORT          reduce using rule 32 (opmat -> DIVIDE .)
    INCREMENT       reduce using rule 32 (opmat -> DIVIDE .)
    DECREMENT       reduce using rule 32 (opmat -> DIVIDE .)
    COMPASSIGPLUS   reduce using rule 32 (opmat -> DIVIDE .)
    COMPASSIGMINUS  reduce using rule 32 (opmat -> DIVIDE .)
    COMPASSIGTIMES  reduce using rule 32 (opmat -> DIVIDE .)
    COMPASSIGDIVIDE reduce using rule 32 (opmat -> DIVIDE .)


state 42

    (33) opmat -> MOD .

    VARIABLE        reduce using rule 33 (opmat -> MOD .)
    WHILE           reduce using rule 33 (opmat -> MOD .)
    FOR             reduce using rule 33 (opmat -> MOD .)
    IF              reduce using rule 33 (opmat -> MOD .)
    LPAREN          reduce using rule 33 (opmat -> MOD .)
    NUMBER          reduce using rule 33 (opmat -> MOD .)
    TRUE            reduce using rule 33 (opmat -> MOD .)
    FALSE           reduce using rule 33 (opmat -> MOD .)
    BOOL            reduce using rule 33 (opmat -> MOD .)
    BYTE            reduce using rule 33 (opmat -> MOD .)
    CHAR            reduce using rule 33 (opmat -> MOD .)
    DECIMAL         reduce using rule 33 (opmat -> MOD .)
    DOUBLE          reduce using rule 33 (opmat -> MOD .)
    FLOAT           reduce using rule 33 (opmat -> MOD .)
    INT             reduce using rule 33 (opmat -> MOD .)
    LONG            reduce using rule 33 (opmat -> MOD .)
    SBYTE           reduce using rule 33 (opmat -> MOD .)
    SHORT           reduce using rule 33 (opmat -> MOD .)
    UINT            reduce using rule 33 (opmat -> MOD .)
    ULONG           reduce using rule 33 (opmat -> MOD .)
    USHORT          reduce using rule 33 (opmat -> MOD .)
    INCREMENT       reduce using rule 33 (opmat -> MOD .)
    DECREMENT       reduce using rule 33 (opmat -> MOD .)
    COMPASSIGPLUS   reduce using rule 33 (opmat -> MOD .)
    COMPASSIGMINUS  reduce using rule 33 (opmat -> MOD .)
    COMPASSIGTIMES  reduce using rule 33 (opmat -> MOD .)
    COMPASSIGDIVIDE reduce using rule 33 (opmat -> MOD .)


state 43

    (23) oplog -> EQUAL .

    NUMBER          reduce using rule 23 (oplog -> EQUAL .)
    TRUE            reduce using rule 23 (oplog -> EQUAL .)
    FALSE           reduce using rule 23 (oplog -> EQUAL .)
    VARIABLE        reduce using rule 23 (oplog -> EQUAL .)


state 44

    (24) oplog -> NOTEQUAL .

    NUMBER          reduce using rule 24 (oplog -> NOTEQUAL .)
    TRUE            reduce using rule 24 (oplog -> NOTEQUAL .)
    FALSE           reduce using rule 24 (oplog -> NOTEQUAL .)
    VARIABLE        reduce using rule 24 (oplog -> NOTEQUAL .)


state 45

    (25) oplog -> GREATERTHAN .

    NUMBER          reduce using rule 25 (oplog -> GREATERTHAN .)
    TRUE            reduce using rule 25 (oplog -> GREATERTHAN .)
    FALSE           reduce using rule 25 (oplog -> GREATERTHAN .)
    VARIABLE        reduce using rule 25 (oplog -> GREATERTHAN .)


state 46

    (26) oplog -> GREATERTHANEQUAL .

    NUMBER          reduce using rule 26 (oplog -> GREATERTHANEQUAL .)
    TRUE            reduce using rule 26 (oplog -> GREATERTHANEQUAL .)
    FALSE           reduce using rule 26 (oplog -> GREATERTHANEQUAL .)
    VARIABLE        reduce using rule 26 (oplog -> GREATERTHANEQUAL .)


state 47

    (27) oplog -> LESSERTHAN .

    NUMBER          reduce using rule 27 (oplog -> LESSERTHAN .)
    TRUE            reduce using rule 27 (oplog -> LESSERTHAN .)
    FALSE           reduce using rule 27 (oplog -> LESSERTHAN .)
    VARIABLE        reduce using rule 27 (oplog -> LESSERTHAN .)


state 48

    (28) oplog -> LESSERTHANEQUAL .

    NUMBER          reduce using rule 28 (oplog -> LESSERTHANEQUAL .)
    TRUE            reduce using rule 28 (oplog -> LESSERTHANEQUAL .)
    FALSE           reduce using rule 28 (oplog -> LESSERTHANEQUAL .)
    VARIABLE        reduce using rule 28 (oplog -> LESSERTHANEQUAL .)


state 49

    (2) expression -> datos declaracion .

    $end            reduce using rule 2 (expression -> datos declaracion .)
    SEMICOLON       reduce using rule 2 (expression -> datos declaracion .)
    RBRACKET        reduce using rule 2 (expression -> datos declaracion .)
    RPAREN          reduce using rule 2 (expression -> datos declaracion .)


state 50

    (19) declaracion -> VARIABLE . ASSIGNMENT expression SEMICOLON

    ASSIGNMENT      shift and go to state 55


state 51

    (7) expression -> expresionlogic connectlog . expresionlogic
    (8) expresionlogic -> . term oplog term
    (9) expresionlogic -> . TRUE
    (10) expresionlogic -> . FALSE
    (40) term -> . factor
    (42) term -> . NUMBER
    (43) term -> . TRUE
    (44) term -> . FALSE
    (41) factor -> . VARIABLE
    (58) factor -> . NUMBER PLUS NUMBER
    (59) factor -> . NUMBER MINUS NUMBER
    (60) factor -> . NUMBER TIMES NUMBER
    (61) factor -> . NUMBER DIVIDE NUMBER
    (62) factor -> . NUMBER MOD NUMBER

    TRUE            shift and go to state 63
    FALSE           shift and go to state 64
    NUMBER          shift and go to state 65
    VARIABLE        shift and go to state 66

    expresionlogic                 shift and go to state 91
    term                           shift and go to state 62
    factor                         shift and go to state 16

state 52

    (21) connectlog -> AND .

    TRUE            reduce using rule 21 (connectlog -> AND .)
    FALSE           reduce using rule 21 (connectlog -> AND .)
    NUMBER          reduce using rule 21 (connectlog -> AND .)
    VARIABLE        reduce using rule 21 (connectlog -> AND .)
    WHILE           reduce using rule 21 (connectlog -> AND .)
    FOR             reduce using rule 21 (connectlog -> AND .)
    IF              reduce using rule 21 (connectlog -> AND .)
    LPAREN          reduce using rule 21 (connectlog -> AND .)
    BOOL            reduce using rule 21 (connectlog -> AND .)
    BYTE            reduce using rule 21 (connectlog -> AND .)
    CHAR            reduce using rule 21 (connectlog -> AND .)
    DECIMAL         reduce using rule 21 (connectlog -> AND .)
    DOUBLE          reduce using rule 21 (connectlog -> AND .)
    FLOAT           reduce using rule 21 (connectlog -> AND .)
    INT             reduce using rule 21 (connectlog -> AND .)
    LONG            reduce using rule 21 (connectlog -> AND .)
    SBYTE           reduce using rule 21 (connectlog -> AND .)
    SHORT           reduce using rule 21 (connectlog -> AND .)
    UINT            reduce using rule 21 (connectlog -> AND .)
    ULONG           reduce using rule 21 (connectlog -> AND .)
    USHORT          reduce using rule 21 (connectlog -> AND .)
    INCREMENT       reduce using rule 21 (connectlog -> AND .)
    DECREMENT       reduce using rule 21 (connectlog -> AND .)
    COMPASSIGPLUS   reduce using rule 21 (connectlog -> AND .)
    COMPASSIGMINUS  reduce using rule 21 (connectlog -> AND .)
    COMPASSIGTIMES  reduce using rule 21 (connectlog -> AND .)
    COMPASSIGDIVIDE reduce using rule 21 (connectlog -> AND .)


state 53

    (22) connectlog -> OR .

    TRUE            reduce using rule 22 (connectlog -> OR .)
    FALSE           reduce using rule 22 (connectlog -> OR .)
    NUMBER          reduce using rule 22 (connectlog -> OR .)
    VARIABLE        reduce using rule 22 (connectlog -> OR .)
    WHILE           reduce using rule 22 (connectlog -> OR .)
    FOR             reduce using rule 22 (connectlog -> OR .)
    IF              reduce using rule 22 (connectlog -> OR .)
    LPAREN          reduce using rule 22 (connectlog -> OR .)
    BOOL            reduce using rule 22 (connectlog -> OR .)
    BYTE            reduce using rule 22 (connectlog -> OR .)
    CHAR            reduce using rule 22 (connectlog -> OR .)
    DECIMAL         reduce using rule 22 (connectlog -> OR .)
    DOUBLE          reduce using rule 22 (connectlog -> OR .)
    FLOAT           reduce using rule 22 (connectlog -> OR .)
    INT             reduce using rule 22 (connectlog -> OR .)
    LONG            reduce using rule 22 (connectlog -> OR .)
    SBYTE           reduce using rule 22 (connectlog -> OR .)
    SHORT           reduce using rule 22 (connectlog -> OR .)
    UINT            reduce using rule 22 (connectlog -> OR .)
    ULONG           reduce using rule 22 (connectlog -> OR .)
    USHORT          reduce using rule 22 (connectlog -> OR .)
    INCREMENT       reduce using rule 22 (connectlog -> OR .)
    DECREMENT       reduce using rule 22 (connectlog -> OR .)
    COMPASSIGPLUS   reduce using rule 22 (connectlog -> OR .)
    COMPASSIGMINUS  reduce using rule 22 (connectlog -> OR .)
    COMPASSIGTIMES  reduce using rule 22 (connectlog -> OR .)
    COMPASSIGDIVIDE reduce using rule 22 (connectlog -> OR .)


state 54

    (11) expression -> VARIABLE assignacion . SEMICOLON

    SEMICOLON       shift and go to state 92


state 55

    (19) declaracion -> VARIABLE ASSIGNMENT . expression SEMICOLON
    (1) expression -> . term
    (2) expression -> . datos declaracion
    (3) expression -> . declaracion
    (4) expression -> . term opmat expression
    (5) expression -> . condicional
    (6) expression -> . expresionlogic
    (7) expression -> . expresionlogic connectlog expresionlogic
    (11) expression -> . VARIABLE assignacion SEMICOLON
    (12) expression -> . assignacion VARIABLE SEMICOLON
    (15) expression -> . WHILE condicional LBRACKET expression RBRACKET
    (16) expression -> . FOR LPAREN datos declaracion expresionlogic SEMICOLON oper RPAREN LBRACKET expression RBRACKET
    (17) expression -> . IF condicional LBRACKET expression RBRACKET
    (20) expression -> . LPAREN condicional connectlog expression RPAREN
    (63) expression -> . NUMBER EQUAL NUMBER
    (64) expression -> . NUMBER NOTEQUAL NUMBER
    (65) expression -> . NUMBER GREATERTHAN NUMBER
    (66) expression -> . NUMBER GREATERTHANEQUAL NUMBER
    (67) expression -> . NUMBER LESSERTHAN NUMBER
    (68) expression -> . NUMBER LESSERTHANEQUAL NUMBER
    (69) expression -> . TRUE AND TRUE
    (70) expression -> . TRUE OR TRUE
    (71) expression -> . TRUE AND FALSE
    (72) expression -> . TRUE OR FALSE
    (73) expression -> . FALSE AND FALSE
    (74) expression -> . FALSE OR FALSE
    (75) expression -> . TRUE EQUAL TRUE
    (76) expression -> . TRUE EQUAL FALSE
    (77) expression -> . FALSE EQUAL FALSE
    (78) expression -> . FALSE EQUAL TRUE
    (79) expression -> . TRUE NOTEQUAL TRUE
    (80) expression -> . TRUE NOTEQUAL FALSE
    (81) expression -> . FALSE NOTEQUAL FALSE
    (82) expression -> . FALSE NOTEQUAL TRUE
    (40) term -> . factor
    (42) term -> . NUMBER
    (43) term -> . TRUE
    (44) term -> . FALSE
    (45) datos -> . BOOL
    (46) datos -> . BYTE
    (47) datos -> . CHAR
    (48) datos -> . DECIMAL
    (49) datos -> . DOUBLE
    (50) datos -> . FLOAT
    (51) datos -> . INT
    (52) datos -> . LONG
    (53) datos -> . SBYTE
    (54) datos -> . SHORT
    (55) datos -> . UINT
    (56) datos -> . ULONG
    (57) datos -> . USHORT
    (19) declaracion -> . VARIABLE ASSIGNMENT expression SEMICOLON
    (18) condicional -> . LPAREN expresionlogic RPAREN
    (8) expresionlogic -> . term oplog term
    (9) expresionlogic -> . TRUE
    (10) expresionlogic -> . FALSE
    (34) assignacion -> . INCREMENT
    (35) assignacion -> . DECREMENT
    (36) assignacion -> . COMPASSIGPLUS
    (37) assignacion -> . COMPASSIGMINUS
    (38) assignacion -> . COMPASSIGTIMES
    (39) assignacion -> . COMPASSIGDIVIDE
    (41) factor -> . VARIABLE
    (58) factor -> . NUMBER PLUS NUMBER
    (59) factor -> . NUMBER MINUS NUMBER
    (60) factor -> . NUMBER TIMES NUMBER
    (61) factor -> . NUMBER DIVIDE NUMBER
    (62) factor -> . NUMBER MOD NUMBER

    VARIABLE        shift and go to state 7
    WHILE           shift and go to state 9
    FOR             shift and go to state 10
    IF              shift and go to state 12
    LPAREN          shift and go to state 11
    NUMBER          shift and go to state 13
    TRUE            shift and go to state 14
    FALSE           shift and go to state 15
    BOOL            shift and go to state 17
    BYTE            shift and go to state 18
    CHAR            shift and go to state 19
    DECIMAL         shift and go to state 20
    DOUBLE          shift and go to state 21
    FLOAT           shift and go to state 22
    INT             shift and go to state 23
    LONG            shift and go to state 24
    SBYTE           shift and go to state 25
    SHORT           shift and go to state 26
    UINT            shift and go to state 27
    ULONG           shift and go to state 28
    USHORT          shift and go to state 29
    INCREMENT       shift and go to state 30
    DECREMENT       shift and go to state 31
    COMPASSIGPLUS   shift and go to state 32
    COMPASSIGMINUS  shift and go to state 33
    COMPASSIGTIMES  shift and go to state 34
    COMPASSIGDIVIDE shift and go to state 35

    expression                     shift and go to state 93
    term                           shift and go to state 2
    datos                          shift and go to state 3
    declaracion                    shift and go to state 4
    condicional                    shift and go to state 5
    expresionlogic                 shift and go to state 6
    assignacion                    shift and go to state 8
    factor                         shift and go to state 16

state 56

    (12) expression -> assignacion VARIABLE . SEMICOLON

    SEMICOLON       shift and go to state 94


state 57

    (15) expression -> WHILE condicional . LBRACKET expression RBRACKET

    LBRACKET        shift and go to state 95


state 58

    (18) condicional -> LPAREN . expresionlogic RPAREN
    (8) expresionlogic -> . term oplog term
    (9) expresionlogic -> . TRUE
    (10) expresionlogic -> . FALSE
    (40) term -> . factor
    (42) term -> . NUMBER
    (43) term -> . TRUE
    (44) term -> . FALSE
    (41) factor -> . VARIABLE
    (58) factor -> . NUMBER PLUS NUMBER
    (59) factor -> . NUMBER MINUS NUMBER
    (60) factor -> . NUMBER TIMES NUMBER
    (61) factor -> . NUMBER DIVIDE NUMBER
    (62) factor -> . NUMBER MOD NUMBER

    TRUE            shift and go to state 63
    FALSE           shift and go to state 64
    NUMBER          shift and go to state 65
    VARIABLE        shift and go to state 66

    expresionlogic                 shift and go to state 61
    term                           shift and go to state 62
    factor                         shift and go to state 16

state 59

    (16) expression -> FOR LPAREN . datos declaracion expresionlogic SEMICOLON oper RPAREN LBRACKET expression RBRACKET
    (45) datos -> . BOOL
    (46) datos -> . BYTE
    (47) datos -> . CHAR
    (48) datos -> . DECIMAL
    (49) datos -> . DOUBLE
    (50) datos -> . FLOAT
    (51) datos -> . INT
    (52) datos -> . LONG
    (53) datos -> . SBYTE
    (54) datos -> . SHORT
    (55) datos -> . UINT
    (56) datos -> . ULONG
    (57) datos -> . USHORT

    BOOL            shift and go to state 17
    BYTE            shift and go to state 18
    CHAR            shift and go to state 19
    DECIMAL         shift and go to state 20
    DOUBLE          shift and go to state 21
    FLOAT           shift and go to state 22
    INT             shift and go to state 23
    LONG            shift and go to state 24
    SBYTE           shift and go to state 25
    SHORT           shift and go to state 26
    UINT            shift and go to state 27
    ULONG           shift and go to state 28
    USHORT          shift and go to state 29

    datos                          shift and go to state 96

state 60

    (20) expression -> LPAREN condicional . connectlog expression RPAREN
    (21) connectlog -> . AND
    (22) connectlog -> . OR

    AND             shift and go to state 52
    OR              shift and go to state 53

    connectlog                     shift and go to state 97

state 61

    (18) condicional -> LPAREN expresionlogic . RPAREN

    RPAREN          shift and go to state 98


state 62

    (8) expresionlogic -> term . oplog term
    (23) oplog -> . EQUAL
    (24) oplog -> . NOTEQUAL
    (25) oplog -> . GREATERTHAN
    (26) oplog -> . GREATERTHANEQUAL
    (27) oplog -> . LESSERTHAN
    (28) oplog -> . LESSERTHANEQUAL

    EQUAL           shift and go to state 43
    NOTEQUAL        shift and go to state 44
    GREATERTHAN     shift and go to state 45
    GREATERTHANEQUAL shift and go to state 46
    LESSERTHAN      shift and go to state 47
    LESSERTHANEQUAL shift and go to state 48

    oplog                          shift and go to state 37

state 63

    (9) expresionlogic -> TRUE .
    (43) term -> TRUE .

    RPAREN          reduce using rule 9 (expresionlogic -> TRUE .)
    $end            reduce using rule 9 (expresionlogic -> TRUE .)
    SEMICOLON       reduce using rule 9 (expresionlogic -> TRUE .)
    RBRACKET        reduce using rule 9 (expresionlogic -> TRUE .)
    EQUAL           reduce using rule 43 (term -> TRUE .)
    NOTEQUAL        reduce using rule 43 (term -> TRUE .)
    GREATERTHAN     reduce using rule 43 (term -> TRUE .)
    GREATERTHANEQUAL reduce using rule 43 (term -> TRUE .)
    LESSERTHAN      reduce using rule 43 (term -> TRUE .)
    LESSERTHANEQUAL reduce using rule 43 (term -> TRUE .)


state 64

    (10) expresionlogic -> FALSE .
    (44) term -> FALSE .

    RPAREN          reduce using rule 10 (expresionlogic -> FALSE .)
    $end            reduce using rule 10 (expresionlogic -> FALSE .)
    SEMICOLON       reduce using rule 10 (expresionlogic -> FALSE .)
    RBRACKET        reduce using rule 10 (expresionlogic -> FALSE .)
    EQUAL           reduce using rule 44 (term -> FALSE .)
    NOTEQUAL        reduce using rule 44 (term -> FALSE .)
    GREATERTHAN     reduce using rule 44 (term -> FALSE .)
    GREATERTHANEQUAL reduce using rule 44 (term -> FALSE .)
    LESSERTHAN      reduce using rule 44 (term -> FALSE .)
    LESSERTHANEQUAL reduce using rule 44 (term -> FALSE .)


state 65

    (42) term -> NUMBER .
    (58) factor -> NUMBER . PLUS NUMBER
    (59) factor -> NUMBER . MINUS NUMBER
    (60) factor -> NUMBER . TIMES NUMBER
    (61) factor -> NUMBER . DIVIDE NUMBER
    (62) factor -> NUMBER . MOD NUMBER

    EQUAL           reduce using rule 42 (term -> NUMBER .)
    NOTEQUAL        reduce using rule 42 (term -> NUMBER .)
    GREATERTHAN     reduce using rule 42 (term -> NUMBER .)
    GREATERTHANEQUAL reduce using rule 42 (term -> NUMBER .)
    LESSERTHAN      reduce using rule 42 (term -> NUMBER .)
    LESSERTHANEQUAL reduce using rule 42 (term -> NUMBER .)
    AND             reduce using rule 42 (term -> NUMBER .)
    OR              reduce using rule 42 (term -> NUMBER .)
    $end            reduce using rule 42 (term -> NUMBER .)
    RPAREN          reduce using rule 42 (term -> NUMBER .)
    SEMICOLON       reduce using rule 42 (term -> NUMBER .)
    RBRACKET        reduce using rule 42 (term -> NUMBER .)
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75
    TIMES           shift and go to state 76
    DIVIDE          shift and go to state 77
    MOD             shift and go to state 78


state 66

    (41) factor -> VARIABLE .

    EQUAL           reduce using rule 41 (factor -> VARIABLE .)
    NOTEQUAL        reduce using rule 41 (factor -> VARIABLE .)
    GREATERTHAN     reduce using rule 41 (factor -> VARIABLE .)
    GREATERTHANEQUAL reduce using rule 41 (factor -> VARIABLE .)
    LESSERTHAN      reduce using rule 41 (factor -> VARIABLE .)
    LESSERTHANEQUAL reduce using rule 41 (factor -> VARIABLE .)
    AND             reduce using rule 41 (factor -> VARIABLE .)
    OR              reduce using rule 41 (factor -> VARIABLE .)
    $end            reduce using rule 41 (factor -> VARIABLE .)
    RPAREN          reduce using rule 41 (factor -> VARIABLE .)
    SEMICOLON       reduce using rule 41 (factor -> VARIABLE .)
    RBRACKET        reduce using rule 41 (factor -> VARIABLE .)


state 67

    (17) expression -> IF condicional . LBRACKET expression RBRACKET

    LBRACKET        shift and go to state 99


state 68

    (63) expression -> NUMBER EQUAL . NUMBER

    NUMBER          shift and go to state 100


state 69

    (64) expression -> NUMBER NOTEQUAL . NUMBER

    NUMBER          shift and go to state 101


state 70

    (65) expression -> NUMBER GREATERTHAN . NUMBER

    NUMBER          shift and go to state 102


state 71

    (66) expression -> NUMBER GREATERTHANEQUAL . NUMBER

    NUMBER          shift and go to state 103


state 72

    (67) expression -> NUMBER LESSERTHAN . NUMBER

    NUMBER          shift and go to state 104


state 73

    (68) expression -> NUMBER LESSERTHANEQUAL . NUMBER

    NUMBER          shift and go to state 105


state 74

    (58) factor -> NUMBER PLUS . NUMBER

    NUMBER          shift and go to state 106


state 75

    (59) factor -> NUMBER MINUS . NUMBER

    NUMBER          shift and go to state 107


state 76

    (60) factor -> NUMBER TIMES . NUMBER

    NUMBER          shift and go to state 108


state 77

    (61) factor -> NUMBER DIVIDE . NUMBER

    NUMBER          shift and go to state 109


state 78

    (62) factor -> NUMBER MOD . NUMBER

    NUMBER          shift and go to state 110


state 79

    (69) expression -> TRUE AND . TRUE
    (71) expression -> TRUE AND . FALSE

    TRUE            shift and go to state 111
    FALSE           shift and go to state 112


state 80

    (70) expression -> TRUE OR . TRUE
    (72) expression -> TRUE OR . FALSE

    TRUE            shift and go to state 113
    FALSE           shift and go to state 114


state 81

    (75) expression -> TRUE EQUAL . TRUE
    (76) expression -> TRUE EQUAL . FALSE

    TRUE            shift and go to state 115
    FALSE           shift and go to state 116


state 82

    (79) expression -> TRUE NOTEQUAL . TRUE
    (80) expression -> TRUE NOTEQUAL . FALSE

    TRUE            shift and go to state 117
    FALSE           shift and go to state 118


state 83

    (73) expression -> FALSE AND . FALSE

    FALSE           shift and go to state 119


state 84

    (74) expression -> FALSE OR . FALSE

    FALSE           shift and go to state 120


state 85

    (77) expression -> FALSE EQUAL . FALSE
    (78) expression -> FALSE EQUAL . TRUE

    FALSE           shift and go to state 121
    TRUE            shift and go to state 122


state 86

    (81) expression -> FALSE NOTEQUAL . FALSE
    (82) expression -> FALSE NOTEQUAL . TRUE

    FALSE           shift and go to state 123
    TRUE            shift and go to state 124


state 87

    (4) expression -> term opmat expression .

    $end            reduce using rule 4 (expression -> term opmat expression .)
    SEMICOLON       reduce using rule 4 (expression -> term opmat expression .)
    RBRACKET        reduce using rule 4 (expression -> term opmat expression .)
    RPAREN          reduce using rule 4 (expression -> term opmat expression .)


state 88

    (8) expresionlogic -> term oplog term .

    AND             reduce using rule 8 (expresionlogic -> term oplog term .)
    OR              reduce using rule 8 (expresionlogic -> term oplog term .)
    $end            reduce using rule 8 (expresionlogic -> term oplog term .)
    RPAREN          reduce using rule 8 (expresionlogic -> term oplog term .)
    SEMICOLON       reduce using rule 8 (expresionlogic -> term oplog term .)
    RBRACKET        reduce using rule 8 (expresionlogic -> term oplog term .)


state 89

    (43) term -> TRUE .

    AND             reduce using rule 43 (term -> TRUE .)
    OR              reduce using rule 43 (term -> TRUE .)
    $end            reduce using rule 43 (term -> TRUE .)
    RPAREN          reduce using rule 43 (term -> TRUE .)
    SEMICOLON       reduce using rule 43 (term -> TRUE .)
    RBRACKET        reduce using rule 43 (term -> TRUE .)


state 90

    (44) term -> FALSE .

    AND             reduce using rule 44 (term -> FALSE .)
    OR              reduce using rule 44 (term -> FALSE .)
    $end            reduce using rule 44 (term -> FALSE .)
    RPAREN          reduce using rule 44 (term -> FALSE .)
    SEMICOLON       reduce using rule 44 (term -> FALSE .)
    RBRACKET        reduce using rule 44 (term -> FALSE .)


state 91

    (7) expression -> expresionlogic connectlog expresionlogic .

    $end            reduce using rule 7 (expression -> expresionlogic connectlog expresionlogic .)
    SEMICOLON       reduce using rule 7 (expression -> expresionlogic connectlog expresionlogic .)
    RBRACKET        reduce using rule 7 (expression -> expresionlogic connectlog expresionlogic .)
    RPAREN          reduce using rule 7 (expression -> expresionlogic connectlog expresionlogic .)


state 92

    (11) expression -> VARIABLE assignacion SEMICOLON .

    $end            reduce using rule 11 (expression -> VARIABLE assignacion SEMICOLON .)
    SEMICOLON       reduce using rule 11 (expression -> VARIABLE assignacion SEMICOLON .)
    RBRACKET        reduce using rule 11 (expression -> VARIABLE assignacion SEMICOLON .)
    RPAREN          reduce using rule 11 (expression -> VARIABLE assignacion SEMICOLON .)


state 93

    (19) declaracion -> VARIABLE ASSIGNMENT expression . SEMICOLON

    SEMICOLON       shift and go to state 125


state 94

    (12) expression -> assignacion VARIABLE SEMICOLON .

    $end            reduce using rule 12 (expression -> assignacion VARIABLE SEMICOLON .)
    SEMICOLON       reduce using rule 12 (expression -> assignacion VARIABLE SEMICOLON .)
    RBRACKET        reduce using rule 12 (expression -> assignacion VARIABLE SEMICOLON .)
    RPAREN          reduce using rule 12 (expression -> assignacion VARIABLE SEMICOLON .)


state 95

    (15) expression -> WHILE condicional LBRACKET . expression RBRACKET
    (1) expression -> . term
    (2) expression -> . datos declaracion
    (3) expression -> . declaracion
    (4) expression -> . term opmat expression
    (5) expression -> . condicional
    (6) expression -> . expresionlogic
    (7) expression -> . expresionlogic connectlog expresionlogic
    (11) expression -> . VARIABLE assignacion SEMICOLON
    (12) expression -> . assignacion VARIABLE SEMICOLON
    (15) expression -> . WHILE condicional LBRACKET expression RBRACKET
    (16) expression -> . FOR LPAREN datos declaracion expresionlogic SEMICOLON oper RPAREN LBRACKET expression RBRACKET
    (17) expression -> . IF condicional LBRACKET expression RBRACKET
    (20) expression -> . LPAREN condicional connectlog expression RPAREN
    (63) expression -> . NUMBER EQUAL NUMBER
    (64) expression -> . NUMBER NOTEQUAL NUMBER
    (65) expression -> . NUMBER GREATERTHAN NUMBER
    (66) expression -> . NUMBER GREATERTHANEQUAL NUMBER
    (67) expression -> . NUMBER LESSERTHAN NUMBER
    (68) expression -> . NUMBER LESSERTHANEQUAL NUMBER
    (69) expression -> . TRUE AND TRUE
    (70) expression -> . TRUE OR TRUE
    (71) expression -> . TRUE AND FALSE
    (72) expression -> . TRUE OR FALSE
    (73) expression -> . FALSE AND FALSE
    (74) expression -> . FALSE OR FALSE
    (75) expression -> . TRUE EQUAL TRUE
    (76) expression -> . TRUE EQUAL FALSE
    (77) expression -> . FALSE EQUAL FALSE
    (78) expression -> . FALSE EQUAL TRUE
    (79) expression -> . TRUE NOTEQUAL TRUE
    (80) expression -> . TRUE NOTEQUAL FALSE
    (81) expression -> . FALSE NOTEQUAL FALSE
    (82) expression -> . FALSE NOTEQUAL TRUE
    (40) term -> . factor
    (42) term -> . NUMBER
    (43) term -> . TRUE
    (44) term -> . FALSE
    (45) datos -> . BOOL
    (46) datos -> . BYTE
    (47) datos -> . CHAR
    (48) datos -> . DECIMAL
    (49) datos -> . DOUBLE
    (50) datos -> . FLOAT
    (51) datos -> . INT
    (52) datos -> . LONG
    (53) datos -> . SBYTE
    (54) datos -> . SHORT
    (55) datos -> . UINT
    (56) datos -> . ULONG
    (57) datos -> . USHORT
    (19) declaracion -> . VARIABLE ASSIGNMENT expression SEMICOLON
    (18) condicional -> . LPAREN expresionlogic RPAREN
    (8) expresionlogic -> . term oplog term
    (9) expresionlogic -> . TRUE
    (10) expresionlogic -> . FALSE
    (34) assignacion -> . INCREMENT
    (35) assignacion -> . DECREMENT
    (36) assignacion -> . COMPASSIGPLUS
    (37) assignacion -> . COMPASSIGMINUS
    (38) assignacion -> . COMPASSIGTIMES
    (39) assignacion -> . COMPASSIGDIVIDE
    (41) factor -> . VARIABLE
    (58) factor -> . NUMBER PLUS NUMBER
    (59) factor -> . NUMBER MINUS NUMBER
    (60) factor -> . NUMBER TIMES NUMBER
    (61) factor -> . NUMBER DIVIDE NUMBER
    (62) factor -> . NUMBER MOD NUMBER

    VARIABLE        shift and go to state 7
    WHILE           shift and go to state 9
    FOR             shift and go to state 10
    IF              shift and go to state 12
    LPAREN          shift and go to state 11
    NUMBER          shift and go to state 13
    TRUE            shift and go to state 14
    FALSE           shift and go to state 15
    BOOL            shift and go to state 17
    BYTE            shift and go to state 18
    CHAR            shift and go to state 19
    DECIMAL         shift and go to state 20
    DOUBLE          shift and go to state 21
    FLOAT           shift and go to state 22
    INT             shift and go to state 23
    LONG            shift and go to state 24
    SBYTE           shift and go to state 25
    SHORT           shift and go to state 26
    UINT            shift and go to state 27
    ULONG           shift and go to state 28
    USHORT          shift and go to state 29
    INCREMENT       shift and go to state 30
    DECREMENT       shift and go to state 31
    COMPASSIGPLUS   shift and go to state 32
    COMPASSIGMINUS  shift and go to state 33
    COMPASSIGTIMES  shift and go to state 34
    COMPASSIGDIVIDE shift and go to state 35

    condicional                    shift and go to state 5
    expression                     shift and go to state 126
    term                           shift and go to state 2
    datos                          shift and go to state 3
    declaracion                    shift and go to state 4
    expresionlogic                 shift and go to state 6
    assignacion                    shift and go to state 8
    factor                         shift and go to state 16

state 96

    (16) expression -> FOR LPAREN datos . declaracion expresionlogic SEMICOLON oper RPAREN LBRACKET expression RBRACKET
    (19) declaracion -> . VARIABLE ASSIGNMENT expression SEMICOLON

    VARIABLE        shift and go to state 50

    declaracion                    shift and go to state 127

state 97

    (20) expression -> LPAREN condicional connectlog . expression RPAREN
    (1) expression -> . term
    (2) expression -> . datos declaracion
    (3) expression -> . declaracion
    (4) expression -> . term opmat expression
    (5) expression -> . condicional
    (6) expression -> . expresionlogic
    (7) expression -> . expresionlogic connectlog expresionlogic
    (11) expression -> . VARIABLE assignacion SEMICOLON
    (12) expression -> . assignacion VARIABLE SEMICOLON
    (15) expression -> . WHILE condicional LBRACKET expression RBRACKET
    (16) expression -> . FOR LPAREN datos declaracion expresionlogic SEMICOLON oper RPAREN LBRACKET expression RBRACKET
    (17) expression -> . IF condicional LBRACKET expression RBRACKET
    (20) expression -> . LPAREN condicional connectlog expression RPAREN
    (63) expression -> . NUMBER EQUAL NUMBER
    (64) expression -> . NUMBER NOTEQUAL NUMBER
    (65) expression -> . NUMBER GREATERTHAN NUMBER
    (66) expression -> . NUMBER GREATERTHANEQUAL NUMBER
    (67) expression -> . NUMBER LESSERTHAN NUMBER
    (68) expression -> . NUMBER LESSERTHANEQUAL NUMBER
    (69) expression -> . TRUE AND TRUE
    (70) expression -> . TRUE OR TRUE
    (71) expression -> . TRUE AND FALSE
    (72) expression -> . TRUE OR FALSE
    (73) expression -> . FALSE AND FALSE
    (74) expression -> . FALSE OR FALSE
    (75) expression -> . TRUE EQUAL TRUE
    (76) expression -> . TRUE EQUAL FALSE
    (77) expression -> . FALSE EQUAL FALSE
    (78) expression -> . FALSE EQUAL TRUE
    (79) expression -> . TRUE NOTEQUAL TRUE
    (80) expression -> . TRUE NOTEQUAL FALSE
    (81) expression -> . FALSE NOTEQUAL FALSE
    (82) expression -> . FALSE NOTEQUAL TRUE
    (40) term -> . factor
    (42) term -> . NUMBER
    (43) term -> . TRUE
    (44) term -> . FALSE
    (45) datos -> . BOOL
    (46) datos -> . BYTE
    (47) datos -> . CHAR
    (48) datos -> . DECIMAL
    (49) datos -> . DOUBLE
    (50) datos -> . FLOAT
    (51) datos -> . INT
    (52) datos -> . LONG
    (53) datos -> . SBYTE
    (54) datos -> . SHORT
    (55) datos -> . UINT
    (56) datos -> . ULONG
    (57) datos -> . USHORT
    (19) declaracion -> . VARIABLE ASSIGNMENT expression SEMICOLON
    (18) condicional -> . LPAREN expresionlogic RPAREN
    (8) expresionlogic -> . term oplog term
    (9) expresionlogic -> . TRUE
    (10) expresionlogic -> . FALSE
    (34) assignacion -> . INCREMENT
    (35) assignacion -> . DECREMENT
    (36) assignacion -> . COMPASSIGPLUS
    (37) assignacion -> . COMPASSIGMINUS
    (38) assignacion -> . COMPASSIGTIMES
    (39) assignacion -> . COMPASSIGDIVIDE
    (41) factor -> . VARIABLE
    (58) factor -> . NUMBER PLUS NUMBER
    (59) factor -> . NUMBER MINUS NUMBER
    (60) factor -> . NUMBER TIMES NUMBER
    (61) factor -> . NUMBER DIVIDE NUMBER
    (62) factor -> . NUMBER MOD NUMBER

    VARIABLE        shift and go to state 7
    WHILE           shift and go to state 9
    FOR             shift and go to state 10
    IF              shift and go to state 12
    LPAREN          shift and go to state 11
    NUMBER          shift and go to state 13
    TRUE            shift and go to state 14
    FALSE           shift and go to state 15
    BOOL            shift and go to state 17
    BYTE            shift and go to state 18
    CHAR            shift and go to state 19
    DECIMAL         shift and go to state 20
    DOUBLE          shift and go to state 21
    FLOAT           shift and go to state 22
    INT             shift and go to state 23
    LONG            shift and go to state 24
    SBYTE           shift and go to state 25
    SHORT           shift and go to state 26
    UINT            shift and go to state 27
    ULONG           shift and go to state 28
    USHORT          shift and go to state 29
    INCREMENT       shift and go to state 30
    DECREMENT       shift and go to state 31
    COMPASSIGPLUS   shift and go to state 32
    COMPASSIGMINUS  shift and go to state 33
    COMPASSIGTIMES  shift and go to state 34
    COMPASSIGDIVIDE shift and go to state 35

    condicional                    shift and go to state 5
    expression                     shift and go to state 128
    term                           shift and go to state 2
    datos                          shift and go to state 3
    declaracion                    shift and go to state 4
    expresionlogic                 shift and go to state 6
    assignacion                    shift and go to state 8
    factor                         shift and go to state 16

state 98

    (18) condicional -> LPAREN expresionlogic RPAREN .

    $end            reduce using rule 18 (condicional -> LPAREN expresionlogic RPAREN .)
    LBRACKET        reduce using rule 18 (condicional -> LPAREN expresionlogic RPAREN .)
    AND             reduce using rule 18 (condicional -> LPAREN expresionlogic RPAREN .)
    OR              reduce using rule 18 (condicional -> LPAREN expresionlogic RPAREN .)
    SEMICOLON       reduce using rule 18 (condicional -> LPAREN expresionlogic RPAREN .)
    RBRACKET        reduce using rule 18 (condicional -> LPAREN expresionlogic RPAREN .)
    RPAREN          reduce using rule 18 (condicional -> LPAREN expresionlogic RPAREN .)


state 99

    (17) expression -> IF condicional LBRACKET . expression RBRACKET
    (1) expression -> . term
    (2) expression -> . datos declaracion
    (3) expression -> . declaracion
    (4) expression -> . term opmat expression
    (5) expression -> . condicional
    (6) expression -> . expresionlogic
    (7) expression -> . expresionlogic connectlog expresionlogic
    (11) expression -> . VARIABLE assignacion SEMICOLON
    (12) expression -> . assignacion VARIABLE SEMICOLON
    (15) expression -> . WHILE condicional LBRACKET expression RBRACKET
    (16) expression -> . FOR LPAREN datos declaracion expresionlogic SEMICOLON oper RPAREN LBRACKET expression RBRACKET
    (17) expression -> . IF condicional LBRACKET expression RBRACKET
    (20) expression -> . LPAREN condicional connectlog expression RPAREN
    (63) expression -> . NUMBER EQUAL NUMBER
    (64) expression -> . NUMBER NOTEQUAL NUMBER
    (65) expression -> . NUMBER GREATERTHAN NUMBER
    (66) expression -> . NUMBER GREATERTHANEQUAL NUMBER
    (67) expression -> . NUMBER LESSERTHAN NUMBER
    (68) expression -> . NUMBER LESSERTHANEQUAL NUMBER
    (69) expression -> . TRUE AND TRUE
    (70) expression -> . TRUE OR TRUE
    (71) expression -> . TRUE AND FALSE
    (72) expression -> . TRUE OR FALSE
    (73) expression -> . FALSE AND FALSE
    (74) expression -> . FALSE OR FALSE
    (75) expression -> . TRUE EQUAL TRUE
    (76) expression -> . TRUE EQUAL FALSE
    (77) expression -> . FALSE EQUAL FALSE
    (78) expression -> . FALSE EQUAL TRUE
    (79) expression -> . TRUE NOTEQUAL TRUE
    (80) expression -> . TRUE NOTEQUAL FALSE
    (81) expression -> . FALSE NOTEQUAL FALSE
    (82) expression -> . FALSE NOTEQUAL TRUE
    (40) term -> . factor
    (42) term -> . NUMBER
    (43) term -> . TRUE
    (44) term -> . FALSE
    (45) datos -> . BOOL
    (46) datos -> . BYTE
    (47) datos -> . CHAR
    (48) datos -> . DECIMAL
    (49) datos -> . DOUBLE
    (50) datos -> . FLOAT
    (51) datos -> . INT
    (52) datos -> . LONG
    (53) datos -> . SBYTE
    (54) datos -> . SHORT
    (55) datos -> . UINT
    (56) datos -> . ULONG
    (57) datos -> . USHORT
    (19) declaracion -> . VARIABLE ASSIGNMENT expression SEMICOLON
    (18) condicional -> . LPAREN expresionlogic RPAREN
    (8) expresionlogic -> . term oplog term
    (9) expresionlogic -> . TRUE
    (10) expresionlogic -> . FALSE
    (34) assignacion -> . INCREMENT
    (35) assignacion -> . DECREMENT
    (36) assignacion -> . COMPASSIGPLUS
    (37) assignacion -> . COMPASSIGMINUS
    (38) assignacion -> . COMPASSIGTIMES
    (39) assignacion -> . COMPASSIGDIVIDE
    (41) factor -> . VARIABLE
    (58) factor -> . NUMBER PLUS NUMBER
    (59) factor -> . NUMBER MINUS NUMBER
    (60) factor -> . NUMBER TIMES NUMBER
    (61) factor -> . NUMBER DIVIDE NUMBER
    (62) factor -> . NUMBER MOD NUMBER

    VARIABLE        shift and go to state 7
    WHILE           shift and go to state 9
    FOR             shift and go to state 10
    IF              shift and go to state 12
    LPAREN          shift and go to state 11
    NUMBER          shift and go to state 13
    TRUE            shift and go to state 14
    FALSE           shift and go to state 15
    BOOL            shift and go to state 17
    BYTE            shift and go to state 18
    CHAR            shift and go to state 19
    DECIMAL         shift and go to state 20
    DOUBLE          shift and go to state 21
    FLOAT           shift and go to state 22
    INT             shift and go to state 23
    LONG            shift and go to state 24
    SBYTE           shift and go to state 25
    SHORT           shift and go to state 26
    UINT            shift and go to state 27
    ULONG           shift and go to state 28
    USHORT          shift and go to state 29
    INCREMENT       shift and go to state 30
    DECREMENT       shift and go to state 31
    COMPASSIGPLUS   shift and go to state 32
    COMPASSIGMINUS  shift and go to state 33
    COMPASSIGTIMES  shift and go to state 34
    COMPASSIGDIVIDE shift and go to state 35

    condicional                    shift and go to state 5
    expression                     shift and go to state 129
    term                           shift and go to state 2
    datos                          shift and go to state 3
    declaracion                    shift and go to state 4
    expresionlogic                 shift and go to state 6
    assignacion                    shift and go to state 8
    factor                         shift and go to state 16

state 100

    (63) expression -> NUMBER EQUAL NUMBER .

    $end            reduce using rule 63 (expression -> NUMBER EQUAL NUMBER .)
    SEMICOLON       reduce using rule 63 (expression -> NUMBER EQUAL NUMBER .)
    RBRACKET        reduce using rule 63 (expression -> NUMBER EQUAL NUMBER .)
    RPAREN          reduce using rule 63 (expression -> NUMBER EQUAL NUMBER .)


state 101

    (64) expression -> NUMBER NOTEQUAL NUMBER .

    $end            reduce using rule 64 (expression -> NUMBER NOTEQUAL NUMBER .)
    SEMICOLON       reduce using rule 64 (expression -> NUMBER NOTEQUAL NUMBER .)
    RBRACKET        reduce using rule 64 (expression -> NUMBER NOTEQUAL NUMBER .)
    RPAREN          reduce using rule 64 (expression -> NUMBER NOTEQUAL NUMBER .)


state 102

    (65) expression -> NUMBER GREATERTHAN NUMBER .

    $end            reduce using rule 65 (expression -> NUMBER GREATERTHAN NUMBER .)
    SEMICOLON       reduce using rule 65 (expression -> NUMBER GREATERTHAN NUMBER .)
    RBRACKET        reduce using rule 65 (expression -> NUMBER GREATERTHAN NUMBER .)
    RPAREN          reduce using rule 65 (expression -> NUMBER GREATERTHAN NUMBER .)


state 103

    (66) expression -> NUMBER GREATERTHANEQUAL NUMBER .

    $end            reduce using rule 66 (expression -> NUMBER GREATERTHANEQUAL NUMBER .)
    SEMICOLON       reduce using rule 66 (expression -> NUMBER GREATERTHANEQUAL NUMBER .)
    RBRACKET        reduce using rule 66 (expression -> NUMBER GREATERTHANEQUAL NUMBER .)
    RPAREN          reduce using rule 66 (expression -> NUMBER GREATERTHANEQUAL NUMBER .)


state 104

    (67) expression -> NUMBER LESSERTHAN NUMBER .

    $end            reduce using rule 67 (expression -> NUMBER LESSERTHAN NUMBER .)
    SEMICOLON       reduce using rule 67 (expression -> NUMBER LESSERTHAN NUMBER .)
    RBRACKET        reduce using rule 67 (expression -> NUMBER LESSERTHAN NUMBER .)
    RPAREN          reduce using rule 67 (expression -> NUMBER LESSERTHAN NUMBER .)


state 105

    (68) expression -> NUMBER LESSERTHANEQUAL NUMBER .

    $end            reduce using rule 68 (expression -> NUMBER LESSERTHANEQUAL NUMBER .)
    SEMICOLON       reduce using rule 68 (expression -> NUMBER LESSERTHANEQUAL NUMBER .)
    RBRACKET        reduce using rule 68 (expression -> NUMBER LESSERTHANEQUAL NUMBER .)
    RPAREN          reduce using rule 68 (expression -> NUMBER LESSERTHANEQUAL NUMBER .)


state 106

    (58) factor -> NUMBER PLUS NUMBER .

    PLUS            reduce using rule 58 (factor -> NUMBER PLUS NUMBER .)
    MINUS           reduce using rule 58 (factor -> NUMBER PLUS NUMBER .)
    TIMES           reduce using rule 58 (factor -> NUMBER PLUS NUMBER .)
    DIVIDE          reduce using rule 58 (factor -> NUMBER PLUS NUMBER .)
    MOD             reduce using rule 58 (factor -> NUMBER PLUS NUMBER .)
    EQUAL           reduce using rule 58 (factor -> NUMBER PLUS NUMBER .)
    NOTEQUAL        reduce using rule 58 (factor -> NUMBER PLUS NUMBER .)
    GREATERTHAN     reduce using rule 58 (factor -> NUMBER PLUS NUMBER .)
    GREATERTHANEQUAL reduce using rule 58 (factor -> NUMBER PLUS NUMBER .)
    LESSERTHAN      reduce using rule 58 (factor -> NUMBER PLUS NUMBER .)
    LESSERTHANEQUAL reduce using rule 58 (factor -> NUMBER PLUS NUMBER .)
    $end            reduce using rule 58 (factor -> NUMBER PLUS NUMBER .)
    SEMICOLON       reduce using rule 58 (factor -> NUMBER PLUS NUMBER .)
    RBRACKET        reduce using rule 58 (factor -> NUMBER PLUS NUMBER .)
    RPAREN          reduce using rule 58 (factor -> NUMBER PLUS NUMBER .)
    AND             reduce using rule 58 (factor -> NUMBER PLUS NUMBER .)
    OR              reduce using rule 58 (factor -> NUMBER PLUS NUMBER .)


state 107

    (59) factor -> NUMBER MINUS NUMBER .

    PLUS            reduce using rule 59 (factor -> NUMBER MINUS NUMBER .)
    MINUS           reduce using rule 59 (factor -> NUMBER MINUS NUMBER .)
    TIMES           reduce using rule 59 (factor -> NUMBER MINUS NUMBER .)
    DIVIDE          reduce using rule 59 (factor -> NUMBER MINUS NUMBER .)
    MOD             reduce using rule 59 (factor -> NUMBER MINUS NUMBER .)
    EQUAL           reduce using rule 59 (factor -> NUMBER MINUS NUMBER .)
    NOTEQUAL        reduce using rule 59 (factor -> NUMBER MINUS NUMBER .)
    GREATERTHAN     reduce using rule 59 (factor -> NUMBER MINUS NUMBER .)
    GREATERTHANEQUAL reduce using rule 59 (factor -> NUMBER MINUS NUMBER .)
    LESSERTHAN      reduce using rule 59 (factor -> NUMBER MINUS NUMBER .)
    LESSERTHANEQUAL reduce using rule 59 (factor -> NUMBER MINUS NUMBER .)
    $end            reduce using rule 59 (factor -> NUMBER MINUS NUMBER .)
    SEMICOLON       reduce using rule 59 (factor -> NUMBER MINUS NUMBER .)
    RBRACKET        reduce using rule 59 (factor -> NUMBER MINUS NUMBER .)
    RPAREN          reduce using rule 59 (factor -> NUMBER MINUS NUMBER .)
    AND             reduce using rule 59 (factor -> NUMBER MINUS NUMBER .)
    OR              reduce using rule 59 (factor -> NUMBER MINUS NUMBER .)


state 108

    (60) factor -> NUMBER TIMES NUMBER .

    PLUS            reduce using rule 60 (factor -> NUMBER TIMES NUMBER .)
    MINUS           reduce using rule 60 (factor -> NUMBER TIMES NUMBER .)
    TIMES           reduce using rule 60 (factor -> NUMBER TIMES NUMBER .)
    DIVIDE          reduce using rule 60 (factor -> NUMBER TIMES NUMBER .)
    MOD             reduce using rule 60 (factor -> NUMBER TIMES NUMBER .)
    EQUAL           reduce using rule 60 (factor -> NUMBER TIMES NUMBER .)
    NOTEQUAL        reduce using rule 60 (factor -> NUMBER TIMES NUMBER .)
    GREATERTHAN     reduce using rule 60 (factor -> NUMBER TIMES NUMBER .)
    GREATERTHANEQUAL reduce using rule 60 (factor -> NUMBER TIMES NUMBER .)
    LESSERTHAN      reduce using rule 60 (factor -> NUMBER TIMES NUMBER .)
    LESSERTHANEQUAL reduce using rule 60 (factor -> NUMBER TIMES NUMBER .)
    $end            reduce using rule 60 (factor -> NUMBER TIMES NUMBER .)
    SEMICOLON       reduce using rule 60 (factor -> NUMBER TIMES NUMBER .)
    RBRACKET        reduce using rule 60 (factor -> NUMBER TIMES NUMBER .)
    RPAREN          reduce using rule 60 (factor -> NUMBER TIMES NUMBER .)
    AND             reduce using rule 60 (factor -> NUMBER TIMES NUMBER .)
    OR              reduce using rule 60 (factor -> NUMBER TIMES NUMBER .)


state 109

    (61) factor -> NUMBER DIVIDE NUMBER .

    PLUS            reduce using rule 61 (factor -> NUMBER DIVIDE NUMBER .)
    MINUS           reduce using rule 61 (factor -> NUMBER DIVIDE NUMBER .)
    TIMES           reduce using rule 61 (factor -> NUMBER DIVIDE NUMBER .)
    DIVIDE          reduce using rule 61 (factor -> NUMBER DIVIDE NUMBER .)
    MOD             reduce using rule 61 (factor -> NUMBER DIVIDE NUMBER .)
    EQUAL           reduce using rule 61 (factor -> NUMBER DIVIDE NUMBER .)
    NOTEQUAL        reduce using rule 61 (factor -> NUMBER DIVIDE NUMBER .)
    GREATERTHAN     reduce using rule 61 (factor -> NUMBER DIVIDE NUMBER .)
    GREATERTHANEQUAL reduce using rule 61 (factor -> NUMBER DIVIDE NUMBER .)
    LESSERTHAN      reduce using rule 61 (factor -> NUMBER DIVIDE NUMBER .)
    LESSERTHANEQUAL reduce using rule 61 (factor -> NUMBER DIVIDE NUMBER .)
    $end            reduce using rule 61 (factor -> NUMBER DIVIDE NUMBER .)
    SEMICOLON       reduce using rule 61 (factor -> NUMBER DIVIDE NUMBER .)
    RBRACKET        reduce using rule 61 (factor -> NUMBER DIVIDE NUMBER .)
    RPAREN          reduce using rule 61 (factor -> NUMBER DIVIDE NUMBER .)
    AND             reduce using rule 61 (factor -> NUMBER DIVIDE NUMBER .)
    OR              reduce using rule 61 (factor -> NUMBER DIVIDE NUMBER .)


state 110

    (62) factor -> NUMBER MOD NUMBER .

    PLUS            reduce using rule 62 (factor -> NUMBER MOD NUMBER .)
    MINUS           reduce using rule 62 (factor -> NUMBER MOD NUMBER .)
    TIMES           reduce using rule 62 (factor -> NUMBER MOD NUMBER .)
    DIVIDE          reduce using rule 62 (factor -> NUMBER MOD NUMBER .)
    MOD             reduce using rule 62 (factor -> NUMBER MOD NUMBER .)
    EQUAL           reduce using rule 62 (factor -> NUMBER MOD NUMBER .)
    NOTEQUAL        reduce using rule 62 (factor -> NUMBER MOD NUMBER .)
    GREATERTHAN     reduce using rule 62 (factor -> NUMBER MOD NUMBER .)
    GREATERTHANEQUAL reduce using rule 62 (factor -> NUMBER MOD NUMBER .)
    LESSERTHAN      reduce using rule 62 (factor -> NUMBER MOD NUMBER .)
    LESSERTHANEQUAL reduce using rule 62 (factor -> NUMBER MOD NUMBER .)
    $end            reduce using rule 62 (factor -> NUMBER MOD NUMBER .)
    SEMICOLON       reduce using rule 62 (factor -> NUMBER MOD NUMBER .)
    RBRACKET        reduce using rule 62 (factor -> NUMBER MOD NUMBER .)
    RPAREN          reduce using rule 62 (factor -> NUMBER MOD NUMBER .)
    AND             reduce using rule 62 (factor -> NUMBER MOD NUMBER .)
    OR              reduce using rule 62 (factor -> NUMBER MOD NUMBER .)


state 111

    (69) expression -> TRUE AND TRUE .

    $end            reduce using rule 69 (expression -> TRUE AND TRUE .)
    SEMICOLON       reduce using rule 69 (expression -> TRUE AND TRUE .)
    RBRACKET        reduce using rule 69 (expression -> TRUE AND TRUE .)
    RPAREN          reduce using rule 69 (expression -> TRUE AND TRUE .)


state 112

    (71) expression -> TRUE AND FALSE .

    $end            reduce using rule 71 (expression -> TRUE AND FALSE .)
    SEMICOLON       reduce using rule 71 (expression -> TRUE AND FALSE .)
    RBRACKET        reduce using rule 71 (expression -> TRUE AND FALSE .)
    RPAREN          reduce using rule 71 (expression -> TRUE AND FALSE .)


state 113

    (70) expression -> TRUE OR TRUE .

    $end            reduce using rule 70 (expression -> TRUE OR TRUE .)
    SEMICOLON       reduce using rule 70 (expression -> TRUE OR TRUE .)
    RBRACKET        reduce using rule 70 (expression -> TRUE OR TRUE .)
    RPAREN          reduce using rule 70 (expression -> TRUE OR TRUE .)


state 114

    (72) expression -> TRUE OR FALSE .

    $end            reduce using rule 72 (expression -> TRUE OR FALSE .)
    SEMICOLON       reduce using rule 72 (expression -> TRUE OR FALSE .)
    RBRACKET        reduce using rule 72 (expression -> TRUE OR FALSE .)
    RPAREN          reduce using rule 72 (expression -> TRUE OR FALSE .)


state 115

    (75) expression -> TRUE EQUAL TRUE .

    $end            reduce using rule 75 (expression -> TRUE EQUAL TRUE .)
    SEMICOLON       reduce using rule 75 (expression -> TRUE EQUAL TRUE .)
    RBRACKET        reduce using rule 75 (expression -> TRUE EQUAL TRUE .)
    RPAREN          reduce using rule 75 (expression -> TRUE EQUAL TRUE .)


state 116

    (76) expression -> TRUE EQUAL FALSE .

    $end            reduce using rule 76 (expression -> TRUE EQUAL FALSE .)
    SEMICOLON       reduce using rule 76 (expression -> TRUE EQUAL FALSE .)
    RBRACKET        reduce using rule 76 (expression -> TRUE EQUAL FALSE .)
    RPAREN          reduce using rule 76 (expression -> TRUE EQUAL FALSE .)


state 117

    (79) expression -> TRUE NOTEQUAL TRUE .

    $end            reduce using rule 79 (expression -> TRUE NOTEQUAL TRUE .)
    SEMICOLON       reduce using rule 79 (expression -> TRUE NOTEQUAL TRUE .)
    RBRACKET        reduce using rule 79 (expression -> TRUE NOTEQUAL TRUE .)
    RPAREN          reduce using rule 79 (expression -> TRUE NOTEQUAL TRUE .)


state 118

    (80) expression -> TRUE NOTEQUAL FALSE .

    $end            reduce using rule 80 (expression -> TRUE NOTEQUAL FALSE .)
    SEMICOLON       reduce using rule 80 (expression -> TRUE NOTEQUAL FALSE .)
    RBRACKET        reduce using rule 80 (expression -> TRUE NOTEQUAL FALSE .)
    RPAREN          reduce using rule 80 (expression -> TRUE NOTEQUAL FALSE .)


state 119

    (73) expression -> FALSE AND FALSE .

    $end            reduce using rule 73 (expression -> FALSE AND FALSE .)
    SEMICOLON       reduce using rule 73 (expression -> FALSE AND FALSE .)
    RBRACKET        reduce using rule 73 (expression -> FALSE AND FALSE .)
    RPAREN          reduce using rule 73 (expression -> FALSE AND FALSE .)


state 120

    (74) expression -> FALSE OR FALSE .

    $end            reduce using rule 74 (expression -> FALSE OR FALSE .)
    SEMICOLON       reduce using rule 74 (expression -> FALSE OR FALSE .)
    RBRACKET        reduce using rule 74 (expression -> FALSE OR FALSE .)
    RPAREN          reduce using rule 74 (expression -> FALSE OR FALSE .)


state 121

    (77) expression -> FALSE EQUAL FALSE .

    $end            reduce using rule 77 (expression -> FALSE EQUAL FALSE .)
    SEMICOLON       reduce using rule 77 (expression -> FALSE EQUAL FALSE .)
    RBRACKET        reduce using rule 77 (expression -> FALSE EQUAL FALSE .)
    RPAREN          reduce using rule 77 (expression -> FALSE EQUAL FALSE .)


state 122

    (78) expression -> FALSE EQUAL TRUE .

    $end            reduce using rule 78 (expression -> FALSE EQUAL TRUE .)
    SEMICOLON       reduce using rule 78 (expression -> FALSE EQUAL TRUE .)
    RBRACKET        reduce using rule 78 (expression -> FALSE EQUAL TRUE .)
    RPAREN          reduce using rule 78 (expression -> FALSE EQUAL TRUE .)


state 123

    (81) expression -> FALSE NOTEQUAL FALSE .

    $end            reduce using rule 81 (expression -> FALSE NOTEQUAL FALSE .)
    SEMICOLON       reduce using rule 81 (expression -> FALSE NOTEQUAL FALSE .)
    RBRACKET        reduce using rule 81 (expression -> FALSE NOTEQUAL FALSE .)
    RPAREN          reduce using rule 81 (expression -> FALSE NOTEQUAL FALSE .)


state 124

    (82) expression -> FALSE NOTEQUAL TRUE .

    $end            reduce using rule 82 (expression -> FALSE NOTEQUAL TRUE .)
    SEMICOLON       reduce using rule 82 (expression -> FALSE NOTEQUAL TRUE .)
    RBRACKET        reduce using rule 82 (expression -> FALSE NOTEQUAL TRUE .)
    RPAREN          reduce using rule 82 (expression -> FALSE NOTEQUAL TRUE .)


state 125

    (19) declaracion -> VARIABLE ASSIGNMENT expression SEMICOLON .

    $end            reduce using rule 19 (declaracion -> VARIABLE ASSIGNMENT expression SEMICOLON .)
    SEMICOLON       reduce using rule 19 (declaracion -> VARIABLE ASSIGNMENT expression SEMICOLON .)
    RBRACKET        reduce using rule 19 (declaracion -> VARIABLE ASSIGNMENT expression SEMICOLON .)
    RPAREN          reduce using rule 19 (declaracion -> VARIABLE ASSIGNMENT expression SEMICOLON .)
    TRUE            reduce using rule 19 (declaracion -> VARIABLE ASSIGNMENT expression SEMICOLON .)
    FALSE           reduce using rule 19 (declaracion -> VARIABLE ASSIGNMENT expression SEMICOLON .)
    NUMBER          reduce using rule 19 (declaracion -> VARIABLE ASSIGNMENT expression SEMICOLON .)
    VARIABLE        reduce using rule 19 (declaracion -> VARIABLE ASSIGNMENT expression SEMICOLON .)


state 126

    (15) expression -> WHILE condicional LBRACKET expression . RBRACKET

    RBRACKET        shift and go to state 130


state 127

    (16) expression -> FOR LPAREN datos declaracion . expresionlogic SEMICOLON oper RPAREN LBRACKET expression RBRACKET
    (8) expresionlogic -> . term oplog term
    (9) expresionlogic -> . TRUE
    (10) expresionlogic -> . FALSE
    (40) term -> . factor
    (42) term -> . NUMBER
    (43) term -> . TRUE
    (44) term -> . FALSE
    (41) factor -> . VARIABLE
    (58) factor -> . NUMBER PLUS NUMBER
    (59) factor -> . NUMBER MINUS NUMBER
    (60) factor -> . NUMBER TIMES NUMBER
    (61) factor -> . NUMBER DIVIDE NUMBER
    (62) factor -> . NUMBER MOD NUMBER

    TRUE            shift and go to state 63
    FALSE           shift and go to state 64
    NUMBER          shift and go to state 65
    VARIABLE        shift and go to state 66

    expresionlogic                 shift and go to state 131
    term                           shift and go to state 62
    factor                         shift and go to state 16

state 128

    (20) expression -> LPAREN condicional connectlog expression . RPAREN

    RPAREN          shift and go to state 132


state 129

    (17) expression -> IF condicional LBRACKET expression . RBRACKET

    RBRACKET        shift and go to state 133


state 130

    (15) expression -> WHILE condicional LBRACKET expression RBRACKET .

    $end            reduce using rule 15 (expression -> WHILE condicional LBRACKET expression RBRACKET .)
    SEMICOLON       reduce using rule 15 (expression -> WHILE condicional LBRACKET expression RBRACKET .)
    RBRACKET        reduce using rule 15 (expression -> WHILE condicional LBRACKET expression RBRACKET .)
    RPAREN          reduce using rule 15 (expression -> WHILE condicional LBRACKET expression RBRACKET .)


state 131

    (16) expression -> FOR LPAREN datos declaracion expresionlogic . SEMICOLON oper RPAREN LBRACKET expression RBRACKET

    SEMICOLON       shift and go to state 134


state 132

    (20) expression -> LPAREN condicional connectlog expression RPAREN .

    $end            reduce using rule 20 (expression -> LPAREN condicional connectlog expression RPAREN .)
    SEMICOLON       reduce using rule 20 (expression -> LPAREN condicional connectlog expression RPAREN .)
    RBRACKET        reduce using rule 20 (expression -> LPAREN condicional connectlog expression RPAREN .)
    RPAREN          reduce using rule 20 (expression -> LPAREN condicional connectlog expression RPAREN .)


state 133

    (17) expression -> IF condicional LBRACKET expression RBRACKET .

    $end            reduce using rule 17 (expression -> IF condicional LBRACKET expression RBRACKET .)
    SEMICOLON       reduce using rule 17 (expression -> IF condicional LBRACKET expression RBRACKET .)
    RBRACKET        reduce using rule 17 (expression -> IF condicional LBRACKET expression RBRACKET .)
    RPAREN          reduce using rule 17 (expression -> IF condicional LBRACKET expression RBRACKET .)


state 134

    (16) expression -> FOR LPAREN datos declaracion expresionlogic SEMICOLON . oper RPAREN LBRACKET expression RBRACKET
    (13) oper -> . VARIABLE assignacion
    (14) oper -> . assignacion VARIABLE
    (34) assignacion -> . INCREMENT
    (35) assignacion -> . DECREMENT
    (36) assignacion -> . COMPASSIGPLUS
    (37) assignacion -> . COMPASSIGMINUS
    (38) assignacion -> . COMPASSIGTIMES
    (39) assignacion -> . COMPASSIGDIVIDE

    VARIABLE        shift and go to state 136
    INCREMENT       shift and go to state 30
    DECREMENT       shift and go to state 31
    COMPASSIGPLUS   shift and go to state 32
    COMPASSIGMINUS  shift and go to state 33
    COMPASSIGTIMES  shift and go to state 34
    COMPASSIGDIVIDE shift and go to state 35

    oper                           shift and go to state 135
    assignacion                    shift and go to state 137

state 135

    (16) expression -> FOR LPAREN datos declaracion expresionlogic SEMICOLON oper . RPAREN LBRACKET expression RBRACKET

    RPAREN          shift and go to state 138


state 136

    (13) oper -> VARIABLE . assignacion
    (34) assignacion -> . INCREMENT
    (35) assignacion -> . DECREMENT
    (36) assignacion -> . COMPASSIGPLUS
    (37) assignacion -> . COMPASSIGMINUS
    (38) assignacion -> . COMPASSIGTIMES
    (39) assignacion -> . COMPASSIGDIVIDE

    INCREMENT       shift and go to state 30
    DECREMENT       shift and go to state 31
    COMPASSIGPLUS   shift and go to state 32
    COMPASSIGMINUS  shift and go to state 33
    COMPASSIGTIMES  shift and go to state 34
    COMPASSIGDIVIDE shift and go to state 35

    assignacion                    shift and go to state 139

state 137

    (14) oper -> assignacion . VARIABLE

    VARIABLE        shift and go to state 140


state 138

    (16) expression -> FOR LPAREN datos declaracion expresionlogic SEMICOLON oper RPAREN . LBRACKET expression RBRACKET

    LBRACKET        shift and go to state 141


state 139

    (13) oper -> VARIABLE assignacion .

    RPAREN          reduce using rule 13 (oper -> VARIABLE assignacion .)


state 140

    (14) oper -> assignacion VARIABLE .

    RPAREN          reduce using rule 14 (oper -> assignacion VARIABLE .)


state 141

    (16) expression -> FOR LPAREN datos declaracion expresionlogic SEMICOLON oper RPAREN LBRACKET . expression RBRACKET
    (1) expression -> . term
    (2) expression -> . datos declaracion
    (3) expression -> . declaracion
    (4) expression -> . term opmat expression
    (5) expression -> . condicional
    (6) expression -> . expresionlogic
    (7) expression -> . expresionlogic connectlog expresionlogic
    (11) expression -> . VARIABLE assignacion SEMICOLON
    (12) expression -> . assignacion VARIABLE SEMICOLON
    (15) expression -> . WHILE condicional LBRACKET expression RBRACKET
    (16) expression -> . FOR LPAREN datos declaracion expresionlogic SEMICOLON oper RPAREN LBRACKET expression RBRACKET
    (17) expression -> . IF condicional LBRACKET expression RBRACKET
    (20) expression -> . LPAREN condicional connectlog expression RPAREN
    (63) expression -> . NUMBER EQUAL NUMBER
    (64) expression -> . NUMBER NOTEQUAL NUMBER
    (65) expression -> . NUMBER GREATERTHAN NUMBER
    (66) expression -> . NUMBER GREATERTHANEQUAL NUMBER
    (67) expression -> . NUMBER LESSERTHAN NUMBER
    (68) expression -> . NUMBER LESSERTHANEQUAL NUMBER
    (69) expression -> . TRUE AND TRUE
    (70) expression -> . TRUE OR TRUE
    (71) expression -> . TRUE AND FALSE
    (72) expression -> . TRUE OR FALSE
    (73) expression -> . FALSE AND FALSE
    (74) expression -> . FALSE OR FALSE
    (75) expression -> . TRUE EQUAL TRUE
    (76) expression -> . TRUE EQUAL FALSE
    (77) expression -> . FALSE EQUAL FALSE
    (78) expression -> . FALSE EQUAL TRUE
    (79) expression -> . TRUE NOTEQUAL TRUE
    (80) expression -> . TRUE NOTEQUAL FALSE
    (81) expression -> . FALSE NOTEQUAL FALSE
    (82) expression -> . FALSE NOTEQUAL TRUE
    (40) term -> . factor
    (42) term -> . NUMBER
    (43) term -> . TRUE
    (44) term -> . FALSE
    (45) datos -> . BOOL
    (46) datos -> . BYTE
    (47) datos -> . CHAR
    (48) datos -> . DECIMAL
    (49) datos -> . DOUBLE
    (50) datos -> . FLOAT
    (51) datos -> . INT
    (52) datos -> . LONG
    (53) datos -> . SBYTE
    (54) datos -> . SHORT
    (55) datos -> . UINT
    (56) datos -> . ULONG
    (57) datos -> . USHORT
    (19) declaracion -> . VARIABLE ASSIGNMENT expression SEMICOLON
    (18) condicional -> . LPAREN expresionlogic RPAREN
    (8) expresionlogic -> . term oplog term
    (9) expresionlogic -> . TRUE
    (10) expresionlogic -> . FALSE
    (34) assignacion -> . INCREMENT
    (35) assignacion -> . DECREMENT
    (36) assignacion -> . COMPASSIGPLUS
    (37) assignacion -> . COMPASSIGMINUS
    (38) assignacion -> . COMPASSIGTIMES
    (39) assignacion -> . COMPASSIGDIVIDE
    (41) factor -> . VARIABLE
    (58) factor -> . NUMBER PLUS NUMBER
    (59) factor -> . NUMBER MINUS NUMBER
    (60) factor -> . NUMBER TIMES NUMBER
    (61) factor -> . NUMBER DIVIDE NUMBER
    (62) factor -> . NUMBER MOD NUMBER

    VARIABLE        shift and go to state 7
    WHILE           shift and go to state 9
    FOR             shift and go to state 10
    IF              shift and go to state 12
    LPAREN          shift and go to state 11
    NUMBER          shift and go to state 13
    TRUE            shift and go to state 14
    FALSE           shift and go to state 15
    BOOL            shift and go to state 17
    BYTE            shift and go to state 18
    CHAR            shift and go to state 19
    DECIMAL         shift and go to state 20
    DOUBLE          shift and go to state 21
    FLOAT           shift and go to state 22
    INT             shift and go to state 23
    LONG            shift and go to state 24
    SBYTE           shift and go to state 25
    SHORT           shift and go to state 26
    UINT            shift and go to state 27
    ULONG           shift and go to state 28
    USHORT          shift and go to state 29
    INCREMENT       shift and go to state 30
    DECREMENT       shift and go to state 31
    COMPASSIGPLUS   shift and go to state 32
    COMPASSIGMINUS  shift and go to state 33
    COMPASSIGTIMES  shift and go to state 34
    COMPASSIGDIVIDE shift and go to state 35

    datos                          shift and go to state 3
    declaracion                    shift and go to state 4
    expresionlogic                 shift and go to state 6
    expression                     shift and go to state 142
    term                           shift and go to state 2
    condicional                    shift and go to state 5
    assignacion                    shift and go to state 8
    factor                         shift and go to state 16

state 142

    (16) expression -> FOR LPAREN datos declaracion expresionlogic SEMICOLON oper RPAREN LBRACKET expression . RBRACKET

    RBRACKET        shift and go to state 143


state 143

    (16) expression -> FOR LPAREN datos declaracion expresionlogic SEMICOLON oper RPAREN LBRACKET expression RBRACKET .

    $end            reduce using rule 16 (expression -> FOR LPAREN datos declaracion expresionlogic SEMICOLON oper RPAREN LBRACKET expression RBRACKET .)
    SEMICOLON       reduce using rule 16 (expression -> FOR LPAREN datos declaracion expresionlogic SEMICOLON oper RPAREN LBRACKET expression RBRACKET .)
    RBRACKET        reduce using rule 16 (expression -> FOR LPAREN datos declaracion expresionlogic SEMICOLON oper RPAREN LBRACKET expression RBRACKET .)
    RPAREN          reduce using rule 16 (expression -> FOR LPAREN datos declaracion expresionlogic SEMICOLON oper RPAREN LBRACKET expression RBRACKET .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for EQUAL in state 13 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 13 resolved as shift
WARNING: shift/reduce conflict for GREATERTHAN in state 13 resolved as shift
WARNING: shift/reduce conflict for GREATERTHANEQUAL in state 13 resolved as shift
WARNING: shift/reduce conflict for LESSERTHAN in state 13 resolved as shift
WARNING: shift/reduce conflict for LESSERTHANEQUAL in state 13 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 13 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 13 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 13 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 13 resolved as shift
WARNING: shift/reduce conflict for MOD in state 13 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 14 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 14 resolved as shift
WARNING: shift/reduce conflict for AND in state 14 resolved as shift
WARNING: shift/reduce conflict for OR in state 14 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 15 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 15 resolved as shift
WARNING: shift/reduce conflict for AND in state 15 resolved as shift
WARNING: shift/reduce conflict for OR in state 15 resolved as shift
WARNING: reduce/reduce conflict in state 14 resolved using rule (expresionlogic -> TRUE)
WARNING: rejected rule (term -> TRUE) in state 14
WARNING: reduce/reduce conflict in state 15 resolved using rule (expresionlogic -> FALSE)
WARNING: rejected rule (term -> FALSE) in state 15
